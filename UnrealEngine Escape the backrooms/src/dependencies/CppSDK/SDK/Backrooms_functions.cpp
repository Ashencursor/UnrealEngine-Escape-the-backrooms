#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Backrooms

#include "Basic.hpp"

#include "Backrooms_classes.hpp"
#include "Backrooms_parameters.hpp"


namespace SDK
{

// Function Backrooms.AI_ObjectWC.FinishExecute
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAI_ObjectWC::FinishExecute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AI_ObjectWC", "FinishExecute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.AI_ObjectWC.GetWeight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAI_ObjectWC::GetWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AI_ObjectWC", "GetWeight");

	Params::AI_ObjectWC_GetWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.AI_ObjectWC.OnUpdate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAI_ObjectWC::OnUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AI_ObjectWC", "OnUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.AI_ObjectWC.StartExecute
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAI_ObjectWC::StartExecute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AI_ObjectWC", "StartExecute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.AddXP
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// float                                   XpToAdd                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBackroomsBPFunctionLibrary::AddXP(float XpToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "AddXP");

	Params::BackroomsBPFunctionLibrary_AddXP Parms{};

	Parms.XpToAdd = XpToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.CanNavigationReachPoint
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBackroomsBPFunctionLibrary::CanNavigationReachPoint(class APawn* Pawn, const struct FVector& StartLocation, const struct FVector& EndLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "CanNavigationReachPoint");

	Params::BackroomsBPFunctionLibrary_CanNavigationReachPoint Parms{};

	Parms.Pawn = Pawn;
	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.ClearCharacterFloor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::ClearCharacterFloor(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "ClearCharacterFloor");

	Params::BackroomsBPFunctionLibrary_ClearCharacterFloor Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.ClearVoice
// (Final, Native, Static, Private, BlueprintCallable)

void UBackroomsBPFunctionLibrary::ClearVoice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "ClearVoice");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.DeleteInputSettings
// (Final, Native, Static, Private, BlueprintCallable)

void UBackroomsBPFunctionLibrary::DeleteInputSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "DeleteInputSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.DetectCurrentGesture
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// TArray<float>                           PoseFingerCurls                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UOpenInputGestureDatabase*        GesturesDB                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UBackroomsBPFunctionLibrary::DetectCurrentGesture(const TArray<float>& PoseFingerCurls, class UOpenInputGestureDatabase* GesturesDB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "DetectCurrentGesture");

	Params::BackroomsBPFunctionLibrary_DetectCurrentGesture Parms{};

	Parms.PoseFingerCurls = std::move(PoseFingerCurls);
	Parms.GesturesDB = GesturesDB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetAllSaveGameSlotNames
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UBackroomsBPFunctionLibrary::GetAllSaveGameSlotNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetAllSaveGameSlotNames");

	Params::BackroomsBPFunctionLibrary_GetAllSaveGameSlotNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetDateFromSeconds
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UBackroomsBPFunctionLibrary::GetDateFromSeconds(int32 Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetDateFromSeconds");

	Params::BackroomsBPFunctionLibrary_GetDateFromSeconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetIndexOfClosestSplinePoint
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class USplineComponent*                 SplineComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBackroomsBPFunctionLibrary::GetIndexOfClosestSplinePoint(class USplineComponent* SplineComponent, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetIndexOfClosestSplinePoint");

	Params::BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint Parms{};

	Parms.SplineComponent = SplineComponent;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetPlayerStateArray
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class AGameStateBase*                   GameState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APlayerState*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APlayerState*> UBackroomsBPFunctionLibrary::GetPlayerStateArray(class AGameStateBase* GameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetPlayerStateArray");

	Params::BackroomsBPFunctionLibrary_GetPlayerStateArray Parms{};

	Parms.GameState = GameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetSaveGameSlotsByType
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UBackroomsBPFunctionLibrary::GetSaveGameSlotsByType(const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetSaveGameSlotsByType");

	Params::BackroomsBPFunctionLibrary_GetSaveGameSlotsByType Parms{};

	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetSplinePoints
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class USplineComponent*                 SplineComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UBackroomsBPFunctionLibrary::GetSplinePoints(class USplineComponent* SplineComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetSplinePoints");

	Params::BackroomsBPFunctionLibrary_GetSplinePoints Parms{};

	Parms.SplineComponent = SplineComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.GetSystemTimeSeconds
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        DateTime                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBackroomsBPFunctionLibrary::GetSystemTimeSeconds(const struct FDateTime& DateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "GetSystemTimeSeconds");

	Params::BackroomsBPFunctionLibrary_GetSystemTimeSeconds Parms{};

	Parms.DateTime = std::move(DateTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.IsNoHMDMode
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBackroomsBPFunctionLibrary::IsNoHMDMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "IsNoHMDMode");

	Params::BackroomsBPFunctionLibrary_IsNoHMDMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.K2_IsTearingDown
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsTearingDown                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::K2_IsTearingDown(class UObject* Caller, bool* IsTearingDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "K2_IsTearingDown");

	Params::BackroomsBPFunctionLibrary_K2_IsTearingDown Parms{};

	Parms.Caller = Caller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsTearingDown != nullptr)
		*IsTearingDown = Parms.IsTearingDown;
}


// Function Backrooms.BackroomsBPFunctionLibrary.LoadXP
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBackroomsBPFunctionLibrary::LoadXP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "LoadXP");

	Params::BackroomsBPFunctionLibrary_LoadXP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.PlayRate
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UTimelineComponent*               Timeline                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Sec                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTimelineComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimelineComponent* UBackroomsBPFunctionLibrary::PlayRate(class UTimelineComponent* Timeline, float Sec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "PlayRate");

	Params::BackroomsBPFunctionLibrary_PlayRate Parms{};

	Parms.Timeline = Timeline;
	Parms.Sec = Sec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BackroomsBPFunctionLibrary.ReloadBindings
// (Final, Native, Static, Private, BlueprintCallable)

void UBackroomsBPFunctionLibrary::ReloadBindings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "ReloadBindings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.ResetInputSettings
// (Final, Native, Static, Private, BlueprintCallable)

void UBackroomsBPFunctionLibrary::ResetInputSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "ResetInputSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.ResetWorldTime
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AGameMode*                        GameMode                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::ResetWorldTime(const class AGameMode* GameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "ResetWorldTime");

	Params::BackroomsBPFunctionLibrary_ResetWorldTime Parms{};

	Parms.GameMode = GameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.SaveToClipboard
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           ToClipboard                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::SaveToClipboard(const class FString& ToClipboard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "SaveToClipboard");

	Params::BackroomsBPFunctionLibrary_SaveToClipboard Parms{};

	Parms.ToClipboard = std::move(ToClipboard);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.SetCurrentLevelLogs
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           LevelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::SetCurrentLevelLogs(const class FString& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "SetCurrentLevelLogs");

	Params::BackroomsBPFunctionLibrary_SetCurrentLevelLogs Parms{};

	Parms.LevelName = std::move(LevelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BackroomsBPFunctionLibrary.SetLogValue
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackroomsBPFunctionLibrary::SetLogValue(const class FString& Key, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BackroomsBPFunctionLibrary", "SetLogValue");

	Params::BackroomsBPFunctionLibrary_SetLogValue Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatComponent.DisableAllEngines
// (Final, Native, Public, BlueprintCallable)

void UBoatComponent::DisableAllEngines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "DisableAllEngines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatComponent.DisableAllFloaters
// (Final, Native, Public, BlueprintCallable)

void UBoatComponent::DisableAllFloaters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "DisableAllFloaters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatComponent.EnableAllEngines
// (Final, Native, Public, BlueprintCallable)

void UBoatComponent::EnableAllEngines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "EnableAllEngines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatComponent.EnableAllFloaters
// (Final, Native, Public, BlueprintCallable)

void UBoatComponent::EnableAllFloaters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "EnableAllFloaters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatComponent.GetShipBoundsRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBoatComponent::GetShipBoundsRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "GetShipBoundsRadius");

	Params::BoatComponent_GetShipBoundsRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatComponent.GetXShipPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ABoatPawn*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABoatPawn* UBoatComponent::GetXShipPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "GetXShipPawn");

	Params::BoatComponent_GetXShipPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatComponent.IsEngineInWater
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBoatComponent::IsEngineInWater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "IsEngineInWater");

	Params::BoatComponent_IsEngineInWater Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatComponent.Server_PassMovementInfo
// (Net, Native, Event, Protected, NetServer)
// Parameters:
// struct FRepXShipMovement                NewRepXShipMovement                                    (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UBoatComponent::Server_PassMovementInfo(const struct FRepXShipMovement& NewRepXShipMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatComponent", "Server_PassMovementInfo");

	Params::BoatComponent_Server_PassMovementInfo Parms{};

	Parms.NewRepXShipMovement = std::move(NewRepXShipMovement);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.BlockUsage
// (Native, Public, BlueprintCallable)

void AInteractablePawn::BlockUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "BlockUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnAttemptUse
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    CanUse                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::OnAttemptUse(bool CanUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnAttemptUse");

	Params::InteractablePawn_OnAttemptUse Parms{};

	Parms.CanUse = CanUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnHiddenPossess
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::OnHiddenPossess(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnHiddenPossess");

	Params::InteractablePawn_OnHiddenPossess Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnPossess
// (Native, Event, Public, BlueprintEvent)

void AInteractablePawn::OnPossess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnPossess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnRep_WasUsed
// (Final, Native, Public)

void AInteractablePawn::OnRep_WasUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnRep_WasUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnStartInteracting
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::OnStartInteracting(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnStartInteracting");

	Params::InteractablePawn_OnStartInteracting Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnStopInteracting
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void AInteractablePawn::OnStopInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnStopInteracting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnUnPossess
// (Native, Event, Public, BlueprintEvent)

void AInteractablePawn::OnUnPossess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnUnPossess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnUsedAll
// (Native, Event, Public, BlueprintEvent)

void AInteractablePawn::OnUsedAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnUsedAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnUsedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AInteractablePawn::OnUsedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnUsedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnUsedNotify
// (Native, Event, Public, BlueprintEvent)

void AInteractablePawn::OnUsedNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnUsedNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnUsedServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::OnUsedServer(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnUsedServer");

	Params::InteractablePawn_OnUsedServer Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.OnVRPossess
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bPossess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::OnVRPossess(bool bPossess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "OnVRPossess");

	Params::InteractablePawn_OnVRPossess Parms{};

	Parms.bPossess = bPossess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.ResetUsage
// (Native, Public, BlueprintCallable)

void AInteractablePawn::ResetUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "ResetUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.SetCameraPostProcessing
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::SetCameraPostProcessing(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "SetCameraPostProcessing");

	Params::InteractablePawn_SetCameraPostProcessing Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.SetUsingVR
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPossess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::SetUsingVR(class ACharacter* Character, bool bPossess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "SetUsingVR");

	Params::InteractablePawn_SetUsingVR Parms{};

	Parms.Character = Character;
	Parms.bPossess = bPossess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractablePawn.ToggleMouse
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// bool                                    bHide                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractablePawn::ToggleMouse(bool bHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractablePawn", "ToggleMouse");

	Params::InteractablePawn_ToggleMouse Parms{};

	Parms.bHide = bHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatPawn.AddRotationInput
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   ScaleValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABoatPawn::AddRotationInput(float ScaleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatPawn", "AddRotationInput");

	Params::BoatPawn_AddRotationInput Parms{};

	Parms.ScaleValue = ScaleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.BoatPawn.GetWaterDensity
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABoatPawn::GetWaterDensity(const struct FVector2D& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatPawn", "GetWaterDensity");

	Params::BoatPawn_GetWaterDensity Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatPawn.GetWaterNormal
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ABoatPawn::GetWaterNormal(const struct FVector2D& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatPawn", "GetWaterNormal");

	Params::BoatPawn_GetWaterNormal Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatPawn.GetWaterWorldZ
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABoatPawn::GetWaterWorldZ(const struct FVector2D& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatPawn", "GetWaterWorldZ");

	Params::BoatPawn_GetWaterWorldZ Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.BoatPawn.GetXShipComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBoatComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBoatComponent* ABoatPawn::GetXShipComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoatPawn", "GetXShipComponent");

	Params::BoatPawn_GetXShipComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.InteractableActor.BlockUsage
// (Final, Native, Public, BlueprintCallable)

void AInteractableActor::BlockUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "BlockUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnRep_WasUsed
// (Final, Native, Public)

void AInteractableActor::OnRep_WasUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnRep_WasUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnUsedAll
// (Native, Event, Public, BlueprintEvent)

void AInteractableActor::OnUsedAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnUsedAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnUsedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AInteractableActor::OnUsedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnUsedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnUsedNotify
// (Native, Event, Public, BlueprintEvent)

void AInteractableActor::OnUsedNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnUsedNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.OnUsedServer
// (Net, NetReliable, Native, Event, Public, NetServer)

void AInteractableActor::OnUsedServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnUsedServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableActor.ResetUsage
// (Final, Native, Public, BlueprintCallable)

void AInteractableActor::ResetUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "ResetUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.ClientInteractableActor.OnUsed
// (Native, Event, Public, BlueprintEvent)

void AClientInteractableActor::OnUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInteractableActor", "OnUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.ClientInteractablePawn.OnUsed
// (Native, Event, Public, BlueprintEvent)

void AClientInteractablePawn::OnUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInteractablePawn", "OnUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.CustomUserWidget.RefreshInventory
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomUserWidget::RefreshInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomUserWidget", "RefreshInventory");

	Params::CustomUserWidget_RefreshInventory Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Backrooms.CustomUserWidget.SetHotbarSlot
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomUserWidget::SetHotbarSlot(int32 ItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomUserWidget", "SetHotbarSlot");

	Params::CustomUserWidget_SetHotbarSlot Parms{};

	Parms.ItemSlot = ItemSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Backrooms.CustomUserWidget.ToggleInventory
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsVisible_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomUserWidget::ToggleInventory(bool IsVisible_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomUserWidget", "ToggleInventory");

	Params::CustomUserWidget_ToggleInventory Parms{};

	Parms.IsVisible_0 = IsVisible_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Backrooms.DroppedItem.EvaluatePhysics
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADroppedItem::EvaluatePhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "EvaluatePhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.DroppedItem.OnBeginFocus
// (Native, Event, Public, BlueprintEvent)

void ADroppedItem::OnBeginFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "OnBeginFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.DroppedItem.OnEndFocus
// (Native, Event, Public, BlueprintEvent)

void ADroppedItem::OnEndFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "OnEndFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.DroppedItem.StopPhysics
// (Final, Native, Private)

void ADroppedItem::StopPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "StopPhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.DroppedItem.UpdatePhysicsLocation
// (Final, Native, Private)

void ADroppedItem::UpdatePhysicsLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "UpdatePhysicsLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlayerState.AddSanity
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyPlayerState::AddSanity(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerState", "AddSanity");

	Params::FancyPlayerState_AddSanity Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlayerState.OnKillPlayer
// (Native, Event, Public, BlueprintEvent)

void AFancyPlayerState::OnKillPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerState", "OnKillPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlayerState.OnRep_Sanity
// (Final, Native, Public)

void AFancyPlayerState::OnRep_Sanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerState", "OnRep_Sanity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlayerState.RemoveSanity
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyPlayerState::RemoveSanity(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerState", "RemoveSanity");

	Params::FancyPlayerState_RemoveSanity Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.ChangeCrosshairVisibility
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::ChangeCrosshairVisibility(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "ChangeCrosshairVisibility");

	Params::FancyCharacter_ChangeCrosshairVisibility Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.CheckPawn
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void AFancyCharacter::CheckPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "CheckPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.CheckSpawnedItems
// (Native, Event, Public, BlueprintEvent)

void AFancyCharacter::CheckSpawnedItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "CheckSpawnedItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.HideItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::HideItem(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "HideItem");

	Params::FancyCharacter_HideItem Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.Interact
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::Interact(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "Interact");

	Params::FancyCharacter_Interact Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.InteractCallBackVR
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::InteractCallBackVR(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "InteractCallBackVR");

	Params::FancyCharacter_InteractCallBackVR Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.KillPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void AFancyCharacter::KillPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "KillPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.OnRep_CanCollide
// (Final, Native, Private)

void AFancyCharacter::OnRep_CanCollide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "OnRep_CanCollide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.OnRep_IsOverlapOnly
// (Final, Native, Private)

void AFancyCharacter::OnRep_IsOverlapOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "OnRep_IsOverlapOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.OnSanityUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Sanity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::OnSanityUpdate(float Sanity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "OnSanityUpdate");

	Params::FancyCharacter_OnSanityUpdate Parms{};

	Parms.Sanity = Sanity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.SetCanCollide
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    ShouldCollide                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::SetCanCollide(bool ShouldCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "SetCanCollide");

	Params::FancyCharacter_SetCanCollide Parms{};

	Parms.ShouldCollide = ShouldCollide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.SetIsOverlapOnly
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    ShouldOverlapOnly                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::SetIsOverlapOnly(bool ShouldOverlapOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "SetIsOverlapOnly");

	Params::FancyCharacter_SetIsOverlapOnly Parms{};

	Parms.ShouldOverlapOnly = ShouldOverlapOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.StopPushing
// (Native, Event, Public, BlueprintEvent)

void AFancyCharacter::StopPushing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "StopPushing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.ToggleBlur
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ShouldBlur                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::ToggleBlur(bool ShouldBlur)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "ToggleBlur");

	Params::FancyCharacter_ToggleBlur Parms{};

	Parms.ShouldBlur = ShouldBlur;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.TogglePlayerLegs
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::TogglePlayerLegs(bool IsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "TogglePlayerLegs");

	Params::FancyCharacter_TogglePlayerLegs Parms{};

	Parms.IsHidden = IsHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.TogglePlayerVisibility
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// bool                                    IsHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFancyCharacter::TogglePlayerVisibility(bool IsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "TogglePlayerVisibility");

	Params::FancyCharacter_TogglePlayerVisibility Parms{};

	Parms.IsHidden = IsHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyCharacter.TryPickup
// (Native, Event, Public, BlueprintEvent)

void AFancyCharacter::TryPickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyCharacter", "TryPickup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameInstance.CheckCurrentEvent
// (Final, Native, Public, BlueprintCallable)

void UFancyGameInstance::CheckCurrentEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "CheckCurrentEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameInstance.CompleteMission
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeCompleted                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMissionStructure                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMissionStructure UFancyGameInstance::CompleteMission(float TimeCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "CompleteMission");

	Params::FancyGameInstance_CompleteMission Parms{};

	Parms.TimeCompleted = TimeCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyGameInstance.CreateMission
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           TargetEscapeLevel                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LevelBaseXP                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LevelTimeLimit                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MissionStructRowName                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyGameInstance::CreateMission(const class FString& TargetEscapeLevel, float LevelBaseXP, float LevelTimeLimit, const class FString& MissionStructRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "CreateMission");

	Params::FancyGameInstance_CreateMission Parms{};

	Parms.TargetEscapeLevel = std::move(TargetEscapeLevel);
	Parms.LevelBaseXP = LevelBaseXP;
	Parms.LevelTimeLimit = LevelTimeLimit;
	Parms.MissionStructRowName = std::move(MissionStructRowName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameInstance.GetCurrentGameLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFancyGameInstance::GetCurrentGameLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "GetCurrentGameLanguage");

	Params::FancyGameInstance_GetCurrentGameLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyGameInstance.InitializeCPPElements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFancyGameInstance::InitializeCPPElements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "InitializeCPPElements");

	Params::FancyGameInstance_InitializeCPPElements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyGameInstance.InitializeStats
// (Final, Native, Public, BlueprintCallable)

void UFancyGameInstance::InitializeStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "InitializeStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameInstance.OnSteamOverlayIsActive
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsOverlayActive                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyGameInstance::OnSteamOverlayIsActive(bool IsOverlayActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "OnSteamOverlayIsActive");

	Params::FancyGameInstance_OnSteamOverlayIsActive Parms{};

	Parms.IsOverlayActive = IsOverlayActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Backrooms.FancyGameInstance.ResetAchievements
// (Final, Native, Public, BlueprintCallable)

void UFancyGameInstance::ResetAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "ResetAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameInstance.UpdateCurrentGameLanguage
// (Final, Native, Public, BlueprintCallable)

void UFancyGameInstance::UpdateCurrentGameLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameInstance", "UpdateCurrentGameLanguage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyGameMode.OnDecreaseSanity
// (Native, Event, Protected, BlueprintEvent)

void AFancyGameMode::OnDecreaseSanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyGameMode", "OnDecreaseSanity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.GripMotionControllerComponent.BP_IsLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGripMotionControllerComponent::BP_IsLocallyControlled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GripMotionControllerComponent", "BP_IsLocallyControlled");

	Params::GripMotionControllerComponent_BP_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.GripMotionControllerComponent.GetPhysicsVelocity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          AngularVelocity                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LinearVelocity                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGripMotionControllerComponent::GetPhysicsVelocity(struct FVector* AngularVelocity, struct FVector* LinearVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GripMotionControllerComponent", "GetPhysicsVelocity");

	Params::GripMotionControllerComponent_GetPhysicsVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AngularVelocity != nullptr)
		*AngularVelocity = std::move(Parms.AngularVelocity);

	if (LinearVelocity != nullptr)
		*LinearVelocity = std::move(Parms.LinearVelocity);
}


// Function Backrooms.GripMotionControllerComponent.OnRep_ReplicatedControllerTransform
// (Native, Public)

void UGripMotionControllerComponent::OnRep_ReplicatedControllerTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GripMotionControllerComponent", "OnRep_ReplicatedControllerTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.GripMotionControllerComponent.Server_SendControllerTransform
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FTransform                       NewTransform                                           (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGripMotionControllerComponent::Server_SendControllerTransform(const struct FTransform& NewTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GripMotionControllerComponent", "Server_SendControllerTransform");

	Params::GripMotionControllerComponent_Server_SendControllerTransform Parms{};

	Parms.NewTransform = std::move(NewTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyMovementComponent.SetSprinting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Sprint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFancyMovementComponent::SetSprinting(bool Sprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyMovementComponent", "SetSprinting");

	Params::FancyMovementComponent_SetSprinting Parms{};

	Parms.Sprint = Sprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.FancyPlayerController.GetObjectScreenRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMeshComponent*             MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFancyPlayerController::GetObjectScreenRadius(class UStaticMeshComponent* MeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerController", "GetObjectScreenRadius");

	Params::FancyPlayerController_GetObjectScreenRadius Parms{};

	Parms.MeshComponent = MeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.FancyPlayerController.OnPlayerTravel
// (Native, Event, Protected, BlueprintEvent)

void AFancyPlayerController::OnPlayerTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FancyPlayerController", "OnPlayerTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InspectableActor.GetMesh
// (Final, Native, Public)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* AInspectableActor::GetMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectableActor", "GetMesh");

	Params::InspectableActor_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.InspectableActor.SetCameraLocation
// (Final, Native, Public)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInspectableActor::SetCameraLocation(class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectableActor", "SetCameraLocation");

	Params::InspectableActor_SetCameraLocation Parms{};

	Parms.CameraComponent = CameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InspectableActor.SetPlayerRef
// (Final, Native, Public)
// Parameters:
// class ACharacter*                       Ref                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInspectableActor::SetPlayerRef(class ACharacter* Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectableActor", "SetPlayerRef");

	Params::InspectableActor_SetPlayerRef Parms{};

	Parms.Ref = Ref;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InspectableActor.SetViewing
// (Final, Native, Public)

void AInspectableActor::SetViewing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspectableActor", "SetViewing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.BlockUsage
// (Final, Native, Public, BlueprintCallable)

void UInteractableComponent::BlockUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "BlockUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.OnRep_WasUsed
// (Final, Native, Public)

void UInteractableComponent::OnRep_WasUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnRep_WasUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.OnUsedAll
// (Native, Event, Public, BlueprintEvent)

void UInteractableComponent::OnUsedAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnUsedAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.OnUsedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UInteractableComponent::OnUsedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnUsedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.OnUsedNotify
// (Native, Event, Public, BlueprintEvent)

void UInteractableComponent::OnUsedNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnUsedNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.OnUsedServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableComponent::OnUsedServer(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "OnUsedServer");

	Params::InteractableComponent_OnUsedServer Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableComponent.ResetUsage
// (Final, Native, Public, BlueprintCallable)

void UInteractableComponent::ResetUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableComponent", "ResetUsage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InteractableInterface.OnActorUsed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractableInterface::OnActorUsed(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableInterface", "OnActorUsed");

	Params::InteractableInterface_OnActorUsed Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InventoryComponent.AddToInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventoryItem*                   Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::AddToInventory(class UInventoryItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "AddToInventory");

	Params::InventoryComponent_AddToInventory Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.InventoryComponent.DropItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::DropItem(uint8 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "DropItem");

	Params::InventoryComponent_DropItem Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InventoryComponent.GetItemAtSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventoryItem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryItem* UInventoryComponent::GetItemAtSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetItemAtSlot");

	Params::InventoryComponent_GetItemAtSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.InventoryComponent.IsSlotEmpty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::IsSlotEmpty(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "IsSlotEmpty");

	Params::InventoryComponent_IsSlotEmpty Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.InventoryComponent.RemoveFromInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventoryItem*                   Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::RemoveFromInventory(class UInventoryItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "RemoveFromInventory");

	Params::InventoryComponent_RemoveFromInventory Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.InventoryComponent.SwapInventoryItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FirstIdx                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SecondIdx                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::SwapInventoryItems(int32 FirstIdx, int32 SecondIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "SwapInventoryItems");

	Params::InventoryComponent_SwapInventoryItems Parms{};

	Parms.FirstIdx = FirstIdx;
	Parms.SecondIdx = SecondIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.ItemActor.CustomInventoryUse
// (Native, Event, Public, BlueprintEvent)

void AItemActor::CustomInventoryUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "CustomInventoryUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.ItemActor.Use
// (Final, Native, Public, BlueprintCallable)

void AItemActor::Use()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "Use");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.Level0Generator.Generate
// (Final, Native, Public, BlueprintCallable)

void ALevel0Generator::Generate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Level0Generator", "Generate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.LIDARBlueprintFunctionLibrary.CreateLiDarDot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLIDARDotStruct                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLIDARDotStruct ULIDARBlueprintFunctionLibrary::CreateLiDarDot(class UObject* Caller, class UTextureRenderTarget2D* RenderTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LIDARBlueprintFunctionLibrary", "CreateLiDarDot");

	Params::LIDARBlueprintFunctionLibrary_CreateLiDarDot Parms{};

	Parms.Caller = Caller;
	Parms.RenderTarget = RenderTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.LIDARBlueprintFunctionLibrary.FindCollisionUVSkeletalMesh
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector2D                        UV                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULIDARBlueprintFunctionLibrary::FindCollisionUVSkeletalMesh(const struct FHitResult& Hit, struct FVector2D* UV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LIDARBlueprintFunctionLibrary", "FindCollisionUVSkeletalMesh");

	Params::LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (UV != nullptr)
		*UV = std::move(Parms.UV);

	return Parms.ReturnValue;
}


// Function Backrooms.LIDARComponent.ShootAuto
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ULIDARComponent::ShootAuto()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LIDARComponent", "ShootAuto");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.LIDARComponent.ShootGun
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ULIDARComponent::ShootGun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LIDARComponent", "ShootGun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.LIDARComponent.ShootReset
// (Final, Native, Public, BlueprintCallable)

void ULIDARComponent::ShootReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LIDARComponent", "ShootReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.LIDARComponent.ScannerTrace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult ULIDARComponent::ScannerTrace(class UStaticMeshComponent* Mesh) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LIDARComponent", "ScannerTrace");

	Params::LIDARComponent_ScannerTrace Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorCharacterMovement.DecreaseSpeedMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DecreaseAmount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::DecreaseSpeedMultiplier(float DecreaseAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "DecreaseSpeedMultiplier");

	Params::MapEditorCharacterMovement_DecreaseSpeedMultiplier Parms{};

	Parms.DecreaseAmount = DecreaseAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.EnterMovementMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::EnterMovementMode(bool Enter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "EnterMovementMode");

	Params::MapEditorCharacterMovement_EnterMovementMode Parms{};

	Parms.Enter = Enter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.IncreaseSpeedMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   IncreaseAmount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::IncreaseSpeedMultiplier(float IncreaseAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "IncreaseSpeedMultiplier");

	Params::MapEditorCharacterMovement_IncreaseSpeedMultiplier Parms{};

	Parms.IncreaseAmount = IncreaseAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.Init
// (Final, Native, Public, BlueprintCallable)

void UMapEditorCharacterMovement::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.LookUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::LookUp(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "LookUp");

	Params::MapEditorCharacterMovement_LookUp Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.MoveForward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::MoveForward(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "MoveForward");

	Params::MapEditorCharacterMovement_MoveForward Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.MoveRight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::MoveRight(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "MoveRight");

	Params::MapEditorCharacterMovement_MoveRight Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.MoveUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::MoveUp(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "MoveUp");

	Params::MapEditorCharacterMovement_MoveUp Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.Server_SetSpeedMultiplier
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   SpeedMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::Server_SetSpeedMultiplier(float SpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "Server_SetSpeedMultiplier");

	Params::MapEditorCharacterMovement_Server_SetSpeedMultiplier Parms{};

	Parms.SpeedMultiplier = SpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.Turn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorCharacterMovement::Turn(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "Turn");

	Params::MapEditorCharacterMovement_Turn Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorCharacterMovement.InMovementMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapEditorCharacterMovement::InMovementMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorCharacterMovement", "InMovementMode");

	Params::MapEditorCharacterMovement_InMovementMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.DeleteActor
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::DeleteActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "DeleteActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.DeselectActor
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::DeselectActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "DeselectActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Grab
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::Grab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Grab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Init
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.MouseTrace
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHitGizmo                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawDebugLine                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UMapEditorHandlerComponent::MouseTrace(float Distance, bool* bHitGizmo, bool bDrawDebugLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "MouseTrace");

	Params::MapEditorHandlerComponent_MouseTrace Parms{};

	Parms.Distance = Distance;
	Parms.bDrawDebugLine = bDrawDebugLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bHitGizmo != nullptr)
		*bHitGizmo = Parms.bHitGizmo;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.OnRep_CurrentActor
// (Final, Native, Protected)

void UMapEditorHandlerComponent::OnRep_CurrentActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "OnRep_CurrentActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Release
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::Release()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Release");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Server_DeleteActor
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::Server_DeleteActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Server_DeleteActor");

	Params::MapEditorHandlerComponent_Server_DeleteActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Server_ReplicateTransform
// (Net, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::Server_ReplicateTransform(class AActor* Actor, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Server_ReplicateTransform");

	Params::MapEditorHandlerComponent_Server_ReplicateTransform Parms{};

	Parms.Actor = Actor;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Server_SpawnActor
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::Server_SpawnActor(TSubclassOf<class AActor> ActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Server_SpawnActor");

	Params::MapEditorHandlerComponent_Server_SpawnActor Parms{};

	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Server_UnpossessToReturnPawn
// (Net, Native, Event, Protected, NetServer, NetValidate)

void UMapEditorHandlerComponent::Server_UnpossessToReturnPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Server_UnpossessToReturnPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.SetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::SetActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "SetActor");

	Params::MapEditorHandlerComponent_SetActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.SetActorTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       NewTransform                                           (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::SetActorTransform(const struct FTransform& NewTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "SetActorTransform");

	Params::MapEditorHandlerComponent_SetActorTransform Parms{};

	Parms.NewTransform = std::move(NewTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.SetReturnPawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::SetReturnPawn(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "SetReturnPawn");

	Params::MapEditorHandlerComponent_SetReturnPawn Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.SetSnapAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMapEditorSnapping               SnappingAmounts                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::SetSnapAmount(const struct FMapEditorSnapping& SnappingAmounts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "SetSnapAmount");

	Params::MapEditorHandlerComponent_SetSnapAmount Parms{};

	Parms.SnappingAmounts = std::move(SnappingAmounts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.ShowMovement
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::ShowMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "ShowMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.ShowRotation
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::ShowRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "ShowRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.ShowScale
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::ShowScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "ShowScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.SpawnActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorHandlerComponent::SpawnActor(TSubclassOf<class AActor> ActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "SpawnActor");

	Params::MapEditorHandlerComponent_SpawnActor Parms{};

	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.Undo
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::Undo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "Undo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.UnpossessToReturnPawn
// (Final, Native, Public, BlueprintCallable)

void UMapEditorHandlerComponent::UnpossessToReturnPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "UnpossessToReturnPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorHandlerComponent.GetActorName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapEditorHandlerComponent::GetActorName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "GetActorName");

	Params::MapEditorHandlerComponent_GetActorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.GetActorTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UMapEditorHandlerComponent::GetActorTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "GetActorTransform");

	Params::MapEditorHandlerComponent_GetActorTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.GetGizmoType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGizmoType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGizmoType UMapEditorHandlerComponent::GetGizmoType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "GetGizmoType");

	Params::MapEditorHandlerComponent_GetGizmoType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.GetReplicationRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMapEditorHandlerComponent::GetReplicationRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "GetReplicationRate");

	Params::MapEditorHandlerComponent_GetReplicationRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.GetSnapAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMapEditorSnapping               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMapEditorSnapping UMapEditorHandlerComponent::GetSnapAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "GetSnapAmount");

	Params::MapEditorHandlerComponent_GetSnapAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorHandlerComponent.HasValidReturnPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapEditorHandlerComponent::HasValidReturnPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorHandlerComponent", "HasValidReturnPawn");

	Params::MapEditorHandlerComponent_HasValidReturnPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorInterface.OnDeleted
// (Event, Public, BlueprintEvent)

void IMapEditorInterface::OnDeleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorInterface", "OnDeleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.MapEditorInterface.OnGrabbed
// (Event, Public, BlueprintEvent)

void IMapEditorInterface::OnGrabbed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorInterface", "OnGrabbed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.MapEditorInterface.OnMaterialLoaded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FMapEditorItemMaterial           MapEditorItemMaterial                                  (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void IMapEditorInterface::OnMaterialLoaded(const struct FMapEditorItemMaterial& MapEditorItemMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorInterface", "OnMaterialLoaded");

	Params::MapEditorInterface_OnMaterialLoaded Parms{};

	Parms.MapEditorItemMaterial = std::move(MapEditorItemMaterial);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorInterface.OnRelease
// (Event, Public, BlueprintEvent)

void IMapEditorInterface::OnRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorInterface", "OnRelease");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.MapEditorInterface.OnScaleChanged
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          NewScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMapEditorInterface::OnScaleChanged(const struct FVector& NewScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorInterface", "OnScaleChanged");

	Params::MapEditorInterface_OnScaleChanged Parms{};

	Parms.NewScale = std::move(NewScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorInterface.OnUndo
// (Event, Public, BlueprintEvent)

void IMapEditorInterface::OnUndo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapEditorInterface", "OnUndo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.MapEditorStatics.ClearMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorStatics::ClearMap(class AActor* WorldActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "ClearMap");

	Params::MapEditorStatics_ClearMap Parms{};

	Parms.WorldActor = WorldActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorStatics.DeSerializeLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           JsonString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMapEditorItems                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMapEditorItems UMapEditorStatics::DeSerializeLevel(const class FString& JsonString, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "DeSerializeLevel");

	Params::MapEditorStatics_DeSerializeLevel Parms{};

	Parms.JsonString = std::move(JsonString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.DoesMapExist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MapDirectory                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapEditorStatics::DoesMapExist(class AActor* WorldActor, const class FString& MapDirectory, const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "DoesMapExist");

	Params::MapEditorStatics_DoesMapExist Parms{};

	Parms.WorldActor = WorldActor;
	Parms.MapDirectory = std::move(MapDirectory);
	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.GetMapList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Directory                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCutLevelname                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowAllMaps                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UMapEditorStatics::GetMapList(class AActor* WorldActor, const class FString& Directory, bool bCutLevelname, bool bShowAllMaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "GetMapList");

	Params::MapEditorStatics_GetMapList Parms{};

	Parms.WorldActor = WorldActor;
	Parms.Directory = std::move(Directory);
	Parms.bCutLevelname = bCutLevelname;
	Parms.bShowAllMaps = bShowAllMaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.GetRealMapName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapEditorStatics::GetRealMapName(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "GetRealMapName");

	Params::MapEditorStatics_GetRealMapName Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.LoadMapFromFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MapDirectory                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Extension                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutString                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FullMapName                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapEditorStatics::LoadMapFromFile(class AActor* WorldActor, const class FString& MapDirectory, const class FString& MapName, const class FString& Extension, class FString* OutString, class FString* FullMapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "LoadMapFromFile");

	Params::MapEditorStatics_LoadMapFromFile Parms{};

	Parms.WorldActor = WorldActor;
	Parms.MapDirectory = std::move(MapDirectory);
	Parms.MapName = std::move(MapName);
	Parms.Extension = std::move(Extension);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutString != nullptr)
		*OutString = std::move(Parms.OutString);

	if (FullMapName != nullptr)
		*FullMapName = std::move(Parms.FullMapName);

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.RemoveExtension
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapEditorStatics::RemoveExtension(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "RemoveExtension");

	Params::MapEditorStatics_RemoveExtension Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.SaveMapToFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MapDirectory                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           StringToSave                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FullMapName                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapEditorStatics::SaveMapToFile(class AActor* WorldActor, const class FString& MapDirectory, const class FString& MapName, const class FString& StringToSave, class FString* FullMapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "SaveMapToFile");

	Params::MapEditorStatics_SaveMapToFile Parms{};

	Parms.WorldActor = WorldActor;
	Parms.MapDirectory = std::move(MapDirectory);
	Parms.MapName = std::move(MapName);
	Parms.StringToSave = std::move(StringToSave);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FullMapName != nullptr)
		*FullMapName = std::move(Parms.FullMapName);

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.SerializeLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapEditorStatics::SerializeLevel(class AActor* WorldActor, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "SerializeLevel");

	Params::MapEditorStatics_SerializeLevel Parms{};

	Parms.WorldActor = WorldActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function Backrooms.MapEditorStatics.SetMaterials
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMapEditorItemMaterial           MapEditorItemMaterial                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMapEditorStatics::SetMaterials(const struct FMapEditorItemMaterial& MapEditorItemMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "SetMaterials");

	Params::MapEditorStatics_SetMaterials Parms{};

	Parms.MapEditorItemMaterial = std::move(MapEditorItemMaterial);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorStatics.SpawnMapItems
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMapEditorItems                  MapItems                                               (Parm, NativeAccessSpecifierPublic)

void UMapEditorStatics::SpawnMapItems(class AActor* WorldActor, const struct FMapEditorItems& MapItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "SpawnMapItems");

	Params::MapEditorStatics_SpawnMapItems Parms{};

	Parms.WorldActor = WorldActor;
	Parms.MapItems = std::move(MapItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MapEditorStatics.SpawnMapItemsFromJson
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           JsonString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapEditorStatics::SpawnMapItemsFromJson(class AActor* WorldActor, const class FString& JsonString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MapEditorStatics", "SpawnMapItemsFromJson");

	Params::MapEditorStatics_SpawnMapItemsFromJson Parms{};

	Parms.WorldActor = WorldActor;
	Parms.JsonString = std::move(JsonString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MissionData.AddEntitySighting
// (Final, Native, Public, BlueprintCallable)

void UMissionData::AddEntitySighting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionData", "AddEntitySighting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MissionData.AddLowSanityAmount
// (Final, Native, Public, BlueprintCallable)

void UMissionData::AddLowSanityAmount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionData", "AddLowSanityAmount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MissionData.AddPlayerDeath
// (Final, Native, Public, BlueprintCallable)

void UMissionData::AddPlayerDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionData", "AddPlayerDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MissionData.SetTimeCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMissionData::SetTimeCompleted(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionData", "SetTimeCompleted");

	Params::MissionData_SetTimeCompleted Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MotionScannerComponent.EndWaveEvent
// (Event, Public, BlueprintEvent)

void UMotionScannerComponent::EndWaveEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionScannerComponent", "EndWaveEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Backrooms.MotionScannerComponent.ScannerWaveUpdateDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// TArray<struct FTargetsStruct>           OutTargets                                             (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTelemetryStruct                 OutTelemetry                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMotionScannerComponent::ScannerWaveUpdateDelegate__DelegateSignature(const TArray<struct FTargetsStruct>& OutTargets, const struct FTelemetryStruct& OutTelemetry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionScannerComponent", "ScannerWaveUpdateDelegate__DelegateSignature");

	Params::MotionScannerComponent_ScannerWaveUpdateDelegate__DelegateSignature Parms{};

	Parms.OutTargets = std::move(OutTargets);
	Parms.OutTelemetry = std::move(OutTelemetry);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Backrooms.MotionScannerComponent.SetNewScanDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SetDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionScannerComponent::SetNewScanDistance(float SetDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionScannerComponent", "SetNewScanDistance");

	Params::MotionScannerComponent_SetNewScanDistance Parms{};

	Parms.SetDistance = SetDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.MotionScannerComponent.StartWaveEvent
// (Event, Public, BlueprintEvent)

void UMotionScannerComponent::StartWaveEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionScannerComponent", "StartWaveEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Backrooms.MotionScannerDirector.CheckLIDARDots
// (Final, Native, Protected, BlueprintCallable)

void AMotionScannerDirector::CheckLIDARDots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionScannerDirector", "CheckLIDARDots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.PushableActor.GetClosesPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APushableActor::GetClosesPoint(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushableActor", "GetClosesPoint");

	Params::PushableActor_GetClosesPoint Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.PushableActor.GetForwardBoundingPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InInvert                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> APushableActor::GetForwardBoundingPoints(bool InInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushableActor", "GetForwardBoundingPoints");

	Params::PushableActor_GetForwardBoundingPoints Parms{};

	Parms.InInvert = InInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.PushableActor.GetRightBoundingPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InInvert                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> APushableActor::GetRightBoundingPoints(bool InInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushableActor", "GetRightBoundingPoints");

	Params::PushableActor_GetRightBoundingPoints Parms{};

	Parms.InInvert = InInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Backrooms.RadarPlayerComponent.EndWaveEvent
// (Event, Public, BlueprintEvent)

void URadarPlayerComponent::EndWaveEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadarPlayerComponent", "EndWaveEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction Backrooms.RadarPlayerComponent.ScannerWaveUpdateDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// TArray<struct FRadarTargetStruct>       OutTargets                                             (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTelemetryStruct                 OutTelemetry                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void URadarPlayerComponent::ScannerWaveUpdateDelegate__DelegateSignature(const TArray<struct FRadarTargetStruct>& OutTargets, const struct FTelemetryStruct& OutTelemetry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadarPlayerComponent", "ScannerWaveUpdateDelegate__DelegateSignature");

	Params::RadarPlayerComponent_ScannerWaveUpdateDelegate__DelegateSignature Parms{};

	Parms.OutTargets = std::move(OutTargets);
	Parms.OutTelemetry = std::move(OutTelemetry);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Backrooms.RadarPlayerComponent.SetNewScanDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SetDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadarPlayerComponent::SetNewScanDistance(float SetDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadarPlayerComponent", "SetNewScanDistance");

	Params::RadarPlayerComponent_SetNewScanDistance Parms{};

	Parms.SetDistance = SetDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Backrooms.RadarPlayerComponent.StartWaveEvent
// (Event, Public, BlueprintEvent)

void URadarPlayerComponent::StartWaveEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadarPlayerComponent", "StartWaveEvent");

	UObject::ProcessEvent(Func, nullptr);
}

}

