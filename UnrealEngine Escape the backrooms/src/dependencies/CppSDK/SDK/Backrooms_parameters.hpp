#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Backrooms

#include "Basic.hpp"

#include "Backrooms_structs.hpp"
#include "XShip_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function Backrooms.AI_ObjectWC.GetWeight
// 0x0001 (0x0001 - 0x0000)
struct AI_ObjectWC_GetWeight final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AI_ObjectWC_GetWeight) == 0x000001, "Wrong alignment on AI_ObjectWC_GetWeight");
static_assert(sizeof(AI_ObjectWC_GetWeight) == 0x000001, "Wrong size on AI_ObjectWC_GetWeight");
static_assert(offsetof(AI_ObjectWC_GetWeight, ReturnValue) == 0x000000, "Member 'AI_ObjectWC_GetWeight::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.AddXP
// 0x0008 (0x0008 - 0x0000)
struct BackroomsBPFunctionLibrary_AddXP final
{
public:
	float                                         XpToAdd;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_AddXP) == 0x000004, "Wrong alignment on BackroomsBPFunctionLibrary_AddXP");
static_assert(sizeof(BackroomsBPFunctionLibrary_AddXP) == 0x000008, "Wrong size on BackroomsBPFunctionLibrary_AddXP");
static_assert(offsetof(BackroomsBPFunctionLibrary_AddXP, XpToAdd) == 0x000000, "Member 'BackroomsBPFunctionLibrary_AddXP::XpToAdd' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_AddXP, ReturnValue) == 0x000004, "Member 'BackroomsBPFunctionLibrary_AddXP::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.CanNavigationReachPoint
// 0x0028 (0x0028 - 0x0000)
struct BackroomsBPFunctionLibrary_CanNavigationReachPoint final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BackroomsBPFunctionLibrary_CanNavigationReachPoint) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_CanNavigationReachPoint");
static_assert(sizeof(BackroomsBPFunctionLibrary_CanNavigationReachPoint) == 0x000028, "Wrong size on BackroomsBPFunctionLibrary_CanNavigationReachPoint");
static_assert(offsetof(BackroomsBPFunctionLibrary_CanNavigationReachPoint, Pawn) == 0x000000, "Member 'BackroomsBPFunctionLibrary_CanNavigationReachPoint::Pawn' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_CanNavigationReachPoint, StartLocation) == 0x000008, "Member 'BackroomsBPFunctionLibrary_CanNavigationReachPoint::StartLocation' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_CanNavigationReachPoint, EndLocation) == 0x000014, "Member 'BackroomsBPFunctionLibrary_CanNavigationReachPoint::EndLocation' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_CanNavigationReachPoint, ReturnValue) == 0x000020, "Member 'BackroomsBPFunctionLibrary_CanNavigationReachPoint::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.ClearCharacterFloor
// 0x0008 (0x0008 - 0x0000)
struct BackroomsBPFunctionLibrary_ClearCharacterFloor final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_ClearCharacterFloor) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_ClearCharacterFloor");
static_assert(sizeof(BackroomsBPFunctionLibrary_ClearCharacterFloor) == 0x000008, "Wrong size on BackroomsBPFunctionLibrary_ClearCharacterFloor");
static_assert(offsetof(BackroomsBPFunctionLibrary_ClearCharacterFloor, Character) == 0x000000, "Member 'BackroomsBPFunctionLibrary_ClearCharacterFloor::Character' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.DetectCurrentGesture
// 0x0020 (0x0020 - 0x0000)
struct BackroomsBPFunctionLibrary_DetectCurrentGesture final
{
public:
	TArray<float>                                 PoseFingerCurls;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UOpenInputGestureDatabase*              GesturesDB;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_DetectCurrentGesture) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_DetectCurrentGesture");
static_assert(sizeof(BackroomsBPFunctionLibrary_DetectCurrentGesture) == 0x000020, "Wrong size on BackroomsBPFunctionLibrary_DetectCurrentGesture");
static_assert(offsetof(BackroomsBPFunctionLibrary_DetectCurrentGesture, PoseFingerCurls) == 0x000000, "Member 'BackroomsBPFunctionLibrary_DetectCurrentGesture::PoseFingerCurls' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_DetectCurrentGesture, GesturesDB) == 0x000010, "Member 'BackroomsBPFunctionLibrary_DetectCurrentGesture::GesturesDB' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_DetectCurrentGesture, ReturnValue) == 0x000018, "Member 'BackroomsBPFunctionLibrary_DetectCurrentGesture::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.GetAllSaveGameSlotNames
// 0x0010 (0x0010 - 0x0000)
struct BackroomsBPFunctionLibrary_GetAllSaveGameSlotNames final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_GetAllSaveGameSlotNames) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_GetAllSaveGameSlotNames");
static_assert(sizeof(BackroomsBPFunctionLibrary_GetAllSaveGameSlotNames) == 0x000010, "Wrong size on BackroomsBPFunctionLibrary_GetAllSaveGameSlotNames");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetAllSaveGameSlotNames, ReturnValue) == 0x000000, "Member 'BackroomsBPFunctionLibrary_GetAllSaveGameSlotNames::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.GetDateFromSeconds
// 0x0010 (0x0010 - 0x0000)
struct BackroomsBPFunctionLibrary_GetDateFromSeconds final
{
public:
	int32                                         Seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_GetDateFromSeconds) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_GetDateFromSeconds");
static_assert(sizeof(BackroomsBPFunctionLibrary_GetDateFromSeconds) == 0x000010, "Wrong size on BackroomsBPFunctionLibrary_GetDateFromSeconds");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetDateFromSeconds, Seconds) == 0x000000, "Member 'BackroomsBPFunctionLibrary_GetDateFromSeconds::Seconds' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetDateFromSeconds, ReturnValue) == 0x000008, "Member 'BackroomsBPFunctionLibrary_GetDateFromSeconds::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.GetIndexOfClosestSplinePoint
// 0x0018 (0x0018 - 0x0000)
struct BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint final
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint");
static_assert(sizeof(BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint) == 0x000018, "Wrong size on BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint, SplineComponent) == 0x000000, "Member 'BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint::SplineComponent' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint, WorldLocation) == 0x000008, "Member 'BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint::WorldLocation' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint, ReturnValue) == 0x000014, "Member 'BackroomsBPFunctionLibrary_GetIndexOfClosestSplinePoint::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.GetPlayerStateArray
// 0x0018 (0x0018 - 0x0000)
struct BackroomsBPFunctionLibrary_GetPlayerStateArray final
{
public:
	class AGameStateBase*                         GameState;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class APlayerState*>                   ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_GetPlayerStateArray) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_GetPlayerStateArray");
static_assert(sizeof(BackroomsBPFunctionLibrary_GetPlayerStateArray) == 0x000018, "Wrong size on BackroomsBPFunctionLibrary_GetPlayerStateArray");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetPlayerStateArray, GameState) == 0x000000, "Member 'BackroomsBPFunctionLibrary_GetPlayerStateArray::GameState' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetPlayerStateArray, ReturnValue) == 0x000008, "Member 'BackroomsBPFunctionLibrary_GetPlayerStateArray::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.GetSaveGameSlotsByType
// 0x0020 (0x0020 - 0x0000)
struct BackroomsBPFunctionLibrary_GetSaveGameSlotsByType final
{
public:
	class FString                                 Prefix;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_GetSaveGameSlotsByType) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_GetSaveGameSlotsByType");
static_assert(sizeof(BackroomsBPFunctionLibrary_GetSaveGameSlotsByType) == 0x000020, "Wrong size on BackroomsBPFunctionLibrary_GetSaveGameSlotsByType");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetSaveGameSlotsByType, Prefix) == 0x000000, "Member 'BackroomsBPFunctionLibrary_GetSaveGameSlotsByType::Prefix' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetSaveGameSlotsByType, ReturnValue) == 0x000010, "Member 'BackroomsBPFunctionLibrary_GetSaveGameSlotsByType::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.GetSplinePoints
// 0x0018 (0x0018 - 0x0000)
struct BackroomsBPFunctionLibrary_GetSplinePoints final
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_GetSplinePoints) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_GetSplinePoints");
static_assert(sizeof(BackroomsBPFunctionLibrary_GetSplinePoints) == 0x000018, "Wrong size on BackroomsBPFunctionLibrary_GetSplinePoints");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetSplinePoints, SplineComponent) == 0x000000, "Member 'BackroomsBPFunctionLibrary_GetSplinePoints::SplineComponent' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetSplinePoints, ReturnValue) == 0x000008, "Member 'BackroomsBPFunctionLibrary_GetSplinePoints::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.GetSystemTimeSeconds
// 0x0010 (0x0010 - 0x0000)
struct BackroomsBPFunctionLibrary_GetSystemTimeSeconds final
{
public:
	struct FDateTime                              DateTime;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BackroomsBPFunctionLibrary_GetSystemTimeSeconds) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_GetSystemTimeSeconds");
static_assert(sizeof(BackroomsBPFunctionLibrary_GetSystemTimeSeconds) == 0x000010, "Wrong size on BackroomsBPFunctionLibrary_GetSystemTimeSeconds");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetSystemTimeSeconds, DateTime) == 0x000000, "Member 'BackroomsBPFunctionLibrary_GetSystemTimeSeconds::DateTime' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_GetSystemTimeSeconds, ReturnValue) == 0x000008, "Member 'BackroomsBPFunctionLibrary_GetSystemTimeSeconds::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.IsNoHMDMode
// 0x0001 (0x0001 - 0x0000)
struct BackroomsBPFunctionLibrary_IsNoHMDMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_IsNoHMDMode) == 0x000001, "Wrong alignment on BackroomsBPFunctionLibrary_IsNoHMDMode");
static_assert(sizeof(BackroomsBPFunctionLibrary_IsNoHMDMode) == 0x000001, "Wrong size on BackroomsBPFunctionLibrary_IsNoHMDMode");
static_assert(offsetof(BackroomsBPFunctionLibrary_IsNoHMDMode, ReturnValue) == 0x000000, "Member 'BackroomsBPFunctionLibrary_IsNoHMDMode::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.K2_IsTearingDown
// 0x0010 (0x0010 - 0x0000)
struct BackroomsBPFunctionLibrary_K2_IsTearingDown final
{
public:
	class UObject*                                Caller;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTearingDown;                                     // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BackroomsBPFunctionLibrary_K2_IsTearingDown) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_K2_IsTearingDown");
static_assert(sizeof(BackroomsBPFunctionLibrary_K2_IsTearingDown) == 0x000010, "Wrong size on BackroomsBPFunctionLibrary_K2_IsTearingDown");
static_assert(offsetof(BackroomsBPFunctionLibrary_K2_IsTearingDown, Caller) == 0x000000, "Member 'BackroomsBPFunctionLibrary_K2_IsTearingDown::Caller' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_K2_IsTearingDown, IsTearingDown) == 0x000008, "Member 'BackroomsBPFunctionLibrary_K2_IsTearingDown::IsTearingDown' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.LoadXP
// 0x0004 (0x0004 - 0x0000)
struct BackroomsBPFunctionLibrary_LoadXP final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_LoadXP) == 0x000004, "Wrong alignment on BackroomsBPFunctionLibrary_LoadXP");
static_assert(sizeof(BackroomsBPFunctionLibrary_LoadXP) == 0x000004, "Wrong size on BackroomsBPFunctionLibrary_LoadXP");
static_assert(offsetof(BackroomsBPFunctionLibrary_LoadXP, ReturnValue) == 0x000000, "Member 'BackroomsBPFunctionLibrary_LoadXP::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.PlayRate
// 0x0018 (0x0018 - 0x0000)
struct BackroomsBPFunctionLibrary_PlayRate final
{
public:
	class UTimelineComponent*                     Timeline;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sec;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_PlayRate) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_PlayRate");
static_assert(sizeof(BackroomsBPFunctionLibrary_PlayRate) == 0x000018, "Wrong size on BackroomsBPFunctionLibrary_PlayRate");
static_assert(offsetof(BackroomsBPFunctionLibrary_PlayRate, Timeline) == 0x000000, "Member 'BackroomsBPFunctionLibrary_PlayRate::Timeline' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_PlayRate, Sec) == 0x000008, "Member 'BackroomsBPFunctionLibrary_PlayRate::Sec' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_PlayRate, ReturnValue) == 0x000010, "Member 'BackroomsBPFunctionLibrary_PlayRate::ReturnValue' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.ResetWorldTime
// 0x0008 (0x0008 - 0x0000)
struct BackroomsBPFunctionLibrary_ResetWorldTime final
{
public:
	const class AGameMode*                        GameMode;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_ResetWorldTime) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_ResetWorldTime");
static_assert(sizeof(BackroomsBPFunctionLibrary_ResetWorldTime) == 0x000008, "Wrong size on BackroomsBPFunctionLibrary_ResetWorldTime");
static_assert(offsetof(BackroomsBPFunctionLibrary_ResetWorldTime, GameMode) == 0x000000, "Member 'BackroomsBPFunctionLibrary_ResetWorldTime::GameMode' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.SaveToClipboard
// 0x0010 (0x0010 - 0x0000)
struct BackroomsBPFunctionLibrary_SaveToClipboard final
{
public:
	class FString                                 ToClipboard;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_SaveToClipboard) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_SaveToClipboard");
static_assert(sizeof(BackroomsBPFunctionLibrary_SaveToClipboard) == 0x000010, "Wrong size on BackroomsBPFunctionLibrary_SaveToClipboard");
static_assert(offsetof(BackroomsBPFunctionLibrary_SaveToClipboard, ToClipboard) == 0x000000, "Member 'BackroomsBPFunctionLibrary_SaveToClipboard::ToClipboard' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.SetCurrentLevelLogs
// 0x0010 (0x0010 - 0x0000)
struct BackroomsBPFunctionLibrary_SetCurrentLevelLogs final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_SetCurrentLevelLogs) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_SetCurrentLevelLogs");
static_assert(sizeof(BackroomsBPFunctionLibrary_SetCurrentLevelLogs) == 0x000010, "Wrong size on BackroomsBPFunctionLibrary_SetCurrentLevelLogs");
static_assert(offsetof(BackroomsBPFunctionLibrary_SetCurrentLevelLogs, LevelName) == 0x000000, "Member 'BackroomsBPFunctionLibrary_SetCurrentLevelLogs::LevelName' has a wrong offset!");

// Function Backrooms.BackroomsBPFunctionLibrary.SetLogValue
// 0x0020 (0x0020 - 0x0000)
struct BackroomsBPFunctionLibrary_SetLogValue final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BackroomsBPFunctionLibrary_SetLogValue) == 0x000008, "Wrong alignment on BackroomsBPFunctionLibrary_SetLogValue");
static_assert(sizeof(BackroomsBPFunctionLibrary_SetLogValue) == 0x000020, "Wrong size on BackroomsBPFunctionLibrary_SetLogValue");
static_assert(offsetof(BackroomsBPFunctionLibrary_SetLogValue, Key) == 0x000000, "Member 'BackroomsBPFunctionLibrary_SetLogValue::Key' has a wrong offset!");
static_assert(offsetof(BackroomsBPFunctionLibrary_SetLogValue, Value) == 0x000010, "Member 'BackroomsBPFunctionLibrary_SetLogValue::Value' has a wrong offset!");

// Function Backrooms.BoatComponent.GetShipBoundsRadius
// 0x0004 (0x0004 - 0x0000)
struct BoatComponent_GetShipBoundsRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoatComponent_GetShipBoundsRadius) == 0x000004, "Wrong alignment on BoatComponent_GetShipBoundsRadius");
static_assert(sizeof(BoatComponent_GetShipBoundsRadius) == 0x000004, "Wrong size on BoatComponent_GetShipBoundsRadius");
static_assert(offsetof(BoatComponent_GetShipBoundsRadius, ReturnValue) == 0x000000, "Member 'BoatComponent_GetShipBoundsRadius::ReturnValue' has a wrong offset!");

// Function Backrooms.BoatComponent.GetXShipPawn
// 0x0008 (0x0008 - 0x0000)
struct BoatComponent_GetXShipPawn final
{
public:
	class ABoatPawn*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoatComponent_GetXShipPawn) == 0x000008, "Wrong alignment on BoatComponent_GetXShipPawn");
static_assert(sizeof(BoatComponent_GetXShipPawn) == 0x000008, "Wrong size on BoatComponent_GetXShipPawn");
static_assert(offsetof(BoatComponent_GetXShipPawn, ReturnValue) == 0x000000, "Member 'BoatComponent_GetXShipPawn::ReturnValue' has a wrong offset!");

// Function Backrooms.BoatComponent.IsEngineInWater
// 0x0001 (0x0001 - 0x0000)
struct BoatComponent_IsEngineInWater final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoatComponent_IsEngineInWater) == 0x000001, "Wrong alignment on BoatComponent_IsEngineInWater");
static_assert(sizeof(BoatComponent_IsEngineInWater) == 0x000001, "Wrong size on BoatComponent_IsEngineInWater");
static_assert(offsetof(BoatComponent_IsEngineInWater, ReturnValue) == 0x000000, "Member 'BoatComponent_IsEngineInWater::ReturnValue' has a wrong offset!");

// Function Backrooms.BoatComponent.Server_PassMovementInfo
// 0x0030 (0x0030 - 0x0000)
struct BoatComponent_Server_PassMovementInfo final
{
public:
	struct FRepXShipMovement                      NewRepXShipMovement;                               // 0x0000(0x0030)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoatComponent_Server_PassMovementInfo) == 0x000004, "Wrong alignment on BoatComponent_Server_PassMovementInfo");
static_assert(sizeof(BoatComponent_Server_PassMovementInfo) == 0x000030, "Wrong size on BoatComponent_Server_PassMovementInfo");
static_assert(offsetof(BoatComponent_Server_PassMovementInfo, NewRepXShipMovement) == 0x000000, "Member 'BoatComponent_Server_PassMovementInfo::NewRepXShipMovement' has a wrong offset!");

// Function Backrooms.InteractablePawn.OnAttemptUse
// 0x0001 (0x0001 - 0x0000)
struct InteractablePawn_OnAttemptUse final
{
public:
	bool                                          CanUse;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractablePawn_OnAttemptUse) == 0x000001, "Wrong alignment on InteractablePawn_OnAttemptUse");
static_assert(sizeof(InteractablePawn_OnAttemptUse) == 0x000001, "Wrong size on InteractablePawn_OnAttemptUse");
static_assert(offsetof(InteractablePawn_OnAttemptUse, CanUse) == 0x000000, "Member 'InteractablePawn_OnAttemptUse::CanUse' has a wrong offset!");

// Function Backrooms.InteractablePawn.OnHiddenPossess
// 0x0008 (0x0008 - 0x0000)
struct InteractablePawn_OnHiddenPossess final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractablePawn_OnHiddenPossess) == 0x000008, "Wrong alignment on InteractablePawn_OnHiddenPossess");
static_assert(sizeof(InteractablePawn_OnHiddenPossess) == 0x000008, "Wrong size on InteractablePawn_OnHiddenPossess");
static_assert(offsetof(InteractablePawn_OnHiddenPossess, Character) == 0x000000, "Member 'InteractablePawn_OnHiddenPossess::Character' has a wrong offset!");

// Function Backrooms.InteractablePawn.OnStartInteracting
// 0x0008 (0x0008 - 0x0000)
struct InteractablePawn_OnStartInteracting final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractablePawn_OnStartInteracting) == 0x000008, "Wrong alignment on InteractablePawn_OnStartInteracting");
static_assert(sizeof(InteractablePawn_OnStartInteracting) == 0x000008, "Wrong size on InteractablePawn_OnStartInteracting");
static_assert(offsetof(InteractablePawn_OnStartInteracting, Character) == 0x000000, "Member 'InteractablePawn_OnStartInteracting::Character' has a wrong offset!");

// Function Backrooms.InteractablePawn.OnUsedServer
// 0x0008 (0x0008 - 0x0000)
struct InteractablePawn_OnUsedServer final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractablePawn_OnUsedServer) == 0x000008, "Wrong alignment on InteractablePawn_OnUsedServer");
static_assert(sizeof(InteractablePawn_OnUsedServer) == 0x000008, "Wrong size on InteractablePawn_OnUsedServer");
static_assert(offsetof(InteractablePawn_OnUsedServer, Character) == 0x000000, "Member 'InteractablePawn_OnUsedServer::Character' has a wrong offset!");

// Function Backrooms.InteractablePawn.OnVRPossess
// 0x0001 (0x0001 - 0x0000)
struct InteractablePawn_OnVRPossess final
{
public:
	bool                                          bPossess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractablePawn_OnVRPossess) == 0x000001, "Wrong alignment on InteractablePawn_OnVRPossess");
static_assert(sizeof(InteractablePawn_OnVRPossess) == 0x000001, "Wrong size on InteractablePawn_OnVRPossess");
static_assert(offsetof(InteractablePawn_OnVRPossess, bPossess) == 0x000000, "Member 'InteractablePawn_OnVRPossess::bPossess' has a wrong offset!");

// Function Backrooms.InteractablePawn.SetCameraPostProcessing
// 0x0008 (0x0008 - 0x0000)
struct InteractablePawn_SetCameraPostProcessing final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractablePawn_SetCameraPostProcessing) == 0x000008, "Wrong alignment on InteractablePawn_SetCameraPostProcessing");
static_assert(sizeof(InteractablePawn_SetCameraPostProcessing) == 0x000008, "Wrong size on InteractablePawn_SetCameraPostProcessing");
static_assert(offsetof(InteractablePawn_SetCameraPostProcessing, Character) == 0x000000, "Member 'InteractablePawn_SetCameraPostProcessing::Character' has a wrong offset!");

// Function Backrooms.InteractablePawn.SetUsingVR
// 0x0010 (0x0010 - 0x0000)
struct InteractablePawn_SetUsingVR final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPossess;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractablePawn_SetUsingVR) == 0x000008, "Wrong alignment on InteractablePawn_SetUsingVR");
static_assert(sizeof(InteractablePawn_SetUsingVR) == 0x000010, "Wrong size on InteractablePawn_SetUsingVR");
static_assert(offsetof(InteractablePawn_SetUsingVR, Character) == 0x000000, "Member 'InteractablePawn_SetUsingVR::Character' has a wrong offset!");
static_assert(offsetof(InteractablePawn_SetUsingVR, bPossess) == 0x000008, "Member 'InteractablePawn_SetUsingVR::bPossess' has a wrong offset!");

// Function Backrooms.InteractablePawn.ToggleMouse
// 0x0001 (0x0001 - 0x0000)
struct InteractablePawn_ToggleMouse final
{
public:
	bool                                          bHide;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractablePawn_ToggleMouse) == 0x000001, "Wrong alignment on InteractablePawn_ToggleMouse");
static_assert(sizeof(InteractablePawn_ToggleMouse) == 0x000001, "Wrong size on InteractablePawn_ToggleMouse");
static_assert(offsetof(InteractablePawn_ToggleMouse, bHide) == 0x000000, "Member 'InteractablePawn_ToggleMouse::bHide' has a wrong offset!");

// Function Backrooms.BoatPawn.AddRotationInput
// 0x0004 (0x0004 - 0x0000)
struct BoatPawn_AddRotationInput final
{
public:
	float                                         ScaleValue;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoatPawn_AddRotationInput) == 0x000004, "Wrong alignment on BoatPawn_AddRotationInput");
static_assert(sizeof(BoatPawn_AddRotationInput) == 0x000004, "Wrong size on BoatPawn_AddRotationInput");
static_assert(offsetof(BoatPawn_AddRotationInput, ScaleValue) == 0x000000, "Member 'BoatPawn_AddRotationInput::ScaleValue' has a wrong offset!");

// Function Backrooms.BoatPawn.GetWaterDensity
// 0x000C (0x000C - 0x0000)
struct BoatPawn_GetWaterDensity final
{
public:
	struct FVector2D                              InLocation;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoatPawn_GetWaterDensity) == 0x000004, "Wrong alignment on BoatPawn_GetWaterDensity");
static_assert(sizeof(BoatPawn_GetWaterDensity) == 0x00000C, "Wrong size on BoatPawn_GetWaterDensity");
static_assert(offsetof(BoatPawn_GetWaterDensity, InLocation) == 0x000000, "Member 'BoatPawn_GetWaterDensity::InLocation' has a wrong offset!");
static_assert(offsetof(BoatPawn_GetWaterDensity, ReturnValue) == 0x000008, "Member 'BoatPawn_GetWaterDensity::ReturnValue' has a wrong offset!");

// Function Backrooms.BoatPawn.GetWaterNormal
// 0x0014 (0x0014 - 0x0000)
struct BoatPawn_GetWaterNormal final
{
public:
	struct FVector2D                              InLocation;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoatPawn_GetWaterNormal) == 0x000004, "Wrong alignment on BoatPawn_GetWaterNormal");
static_assert(sizeof(BoatPawn_GetWaterNormal) == 0x000014, "Wrong size on BoatPawn_GetWaterNormal");
static_assert(offsetof(BoatPawn_GetWaterNormal, InLocation) == 0x000000, "Member 'BoatPawn_GetWaterNormal::InLocation' has a wrong offset!");
static_assert(offsetof(BoatPawn_GetWaterNormal, ReturnValue) == 0x000008, "Member 'BoatPawn_GetWaterNormal::ReturnValue' has a wrong offset!");

// Function Backrooms.BoatPawn.GetWaterWorldZ
// 0x000C (0x000C - 0x0000)
struct BoatPawn_GetWaterWorldZ final
{
public:
	struct FVector2D                              InLocation;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoatPawn_GetWaterWorldZ) == 0x000004, "Wrong alignment on BoatPawn_GetWaterWorldZ");
static_assert(sizeof(BoatPawn_GetWaterWorldZ) == 0x00000C, "Wrong size on BoatPawn_GetWaterWorldZ");
static_assert(offsetof(BoatPawn_GetWaterWorldZ, InLocation) == 0x000000, "Member 'BoatPawn_GetWaterWorldZ::InLocation' has a wrong offset!");
static_assert(offsetof(BoatPawn_GetWaterWorldZ, ReturnValue) == 0x000008, "Member 'BoatPawn_GetWaterWorldZ::ReturnValue' has a wrong offset!");

// Function Backrooms.BoatPawn.GetXShipComponent
// 0x0008 (0x0008 - 0x0000)
struct BoatPawn_GetXShipComponent final
{
public:
	class UBoatComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoatPawn_GetXShipComponent) == 0x000008, "Wrong alignment on BoatPawn_GetXShipComponent");
static_assert(sizeof(BoatPawn_GetXShipComponent) == 0x000008, "Wrong size on BoatPawn_GetXShipComponent");
static_assert(offsetof(BoatPawn_GetXShipComponent, ReturnValue) == 0x000000, "Member 'BoatPawn_GetXShipComponent::ReturnValue' has a wrong offset!");

// Function Backrooms.CustomUserWidget.RefreshInventory
// 0x0001 (0x0001 - 0x0000)
struct CustomUserWidget_RefreshInventory final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomUserWidget_RefreshInventory) == 0x000001, "Wrong alignment on CustomUserWidget_RefreshInventory");
static_assert(sizeof(CustomUserWidget_RefreshInventory) == 0x000001, "Wrong size on CustomUserWidget_RefreshInventory");
static_assert(offsetof(CustomUserWidget_RefreshInventory, ReturnValue) == 0x000000, "Member 'CustomUserWidget_RefreshInventory::ReturnValue' has a wrong offset!");

// Function Backrooms.CustomUserWidget.SetHotbarSlot
// 0x0004 (0x0004 - 0x0000)
struct CustomUserWidget_SetHotbarSlot final
{
public:
	int32                                         ItemSlot;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomUserWidget_SetHotbarSlot) == 0x000004, "Wrong alignment on CustomUserWidget_SetHotbarSlot");
static_assert(sizeof(CustomUserWidget_SetHotbarSlot) == 0x000004, "Wrong size on CustomUserWidget_SetHotbarSlot");
static_assert(offsetof(CustomUserWidget_SetHotbarSlot, ItemSlot) == 0x000000, "Member 'CustomUserWidget_SetHotbarSlot::ItemSlot' has a wrong offset!");

// Function Backrooms.CustomUserWidget.ToggleInventory
// 0x0001 (0x0001 - 0x0000)
struct CustomUserWidget_ToggleInventory final
{
public:
	bool                                          IsVisible_0;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomUserWidget_ToggleInventory) == 0x000001, "Wrong alignment on CustomUserWidget_ToggleInventory");
static_assert(sizeof(CustomUserWidget_ToggleInventory) == 0x000001, "Wrong size on CustomUserWidget_ToggleInventory");
static_assert(offsetof(CustomUserWidget_ToggleInventory, IsVisible_0) == 0x000000, "Member 'CustomUserWidget_ToggleInventory::IsVisible_0' has a wrong offset!");

// Function Backrooms.FancyPlayerState.AddSanity
// 0x0004 (0x0004 - 0x0000)
struct FancyPlayerState_AddSanity final
{
public:
	float                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyPlayerState_AddSanity) == 0x000004, "Wrong alignment on FancyPlayerState_AddSanity");
static_assert(sizeof(FancyPlayerState_AddSanity) == 0x000004, "Wrong size on FancyPlayerState_AddSanity");
static_assert(offsetof(FancyPlayerState_AddSanity, Amount) == 0x000000, "Member 'FancyPlayerState_AddSanity::Amount' has a wrong offset!");

// Function Backrooms.FancyPlayerState.RemoveSanity
// 0x0004 (0x0004 - 0x0000)
struct FancyPlayerState_RemoveSanity final
{
public:
	float                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyPlayerState_RemoveSanity) == 0x000004, "Wrong alignment on FancyPlayerState_RemoveSanity");
static_assert(sizeof(FancyPlayerState_RemoveSanity) == 0x000004, "Wrong size on FancyPlayerState_RemoveSanity");
static_assert(offsetof(FancyPlayerState_RemoveSanity, Amount) == 0x000000, "Member 'FancyPlayerState_RemoveSanity::Amount' has a wrong offset!");

// Function Backrooms.FancyCharacter.ChangeCrosshairVisibility
// 0x0001 (0x0001 - 0x0000)
struct FancyCharacter_ChangeCrosshairVisibility final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyCharacter_ChangeCrosshairVisibility) == 0x000001, "Wrong alignment on FancyCharacter_ChangeCrosshairVisibility");
static_assert(sizeof(FancyCharacter_ChangeCrosshairVisibility) == 0x000001, "Wrong size on FancyCharacter_ChangeCrosshairVisibility");
static_assert(offsetof(FancyCharacter_ChangeCrosshairVisibility, IsVisible) == 0x000000, "Member 'FancyCharacter_ChangeCrosshairVisibility::IsVisible' has a wrong offset!");

// Function Backrooms.FancyCharacter.HideItem
// 0x0001 (0x0001 - 0x0000)
struct FancyCharacter_HideItem final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyCharacter_HideItem) == 0x000001, "Wrong alignment on FancyCharacter_HideItem");
static_assert(sizeof(FancyCharacter_HideItem) == 0x000001, "Wrong size on FancyCharacter_HideItem");
static_assert(offsetof(FancyCharacter_HideItem, IsVisible) == 0x000000, "Member 'FancyCharacter_HideItem::IsVisible' has a wrong offset!");

// Function Backrooms.FancyCharacter.Interact
// 0x0008 (0x0008 - 0x0000)
struct FancyCharacter_Interact final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyCharacter_Interact) == 0x000008, "Wrong alignment on FancyCharacter_Interact");
static_assert(sizeof(FancyCharacter_Interact) == 0x000008, "Wrong size on FancyCharacter_Interact");
static_assert(offsetof(FancyCharacter_Interact, Actor) == 0x000000, "Member 'FancyCharacter_Interact::Actor' has a wrong offset!");

// Function Backrooms.FancyCharacter.InteractCallBackVR
// 0x0008 (0x0008 - 0x0000)
struct FancyCharacter_InteractCallBackVR final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyCharacter_InteractCallBackVR) == 0x000008, "Wrong alignment on FancyCharacter_InteractCallBackVR");
static_assert(sizeof(FancyCharacter_InteractCallBackVR) == 0x000008, "Wrong size on FancyCharacter_InteractCallBackVR");
static_assert(offsetof(FancyCharacter_InteractCallBackVR, Actor) == 0x000000, "Member 'FancyCharacter_InteractCallBackVR::Actor' has a wrong offset!");

// Function Backrooms.FancyCharacter.OnSanityUpdate
// 0x0004 (0x0004 - 0x0000)
struct FancyCharacter_OnSanityUpdate final
{
public:
	float                                         Sanity;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyCharacter_OnSanityUpdate) == 0x000004, "Wrong alignment on FancyCharacter_OnSanityUpdate");
static_assert(sizeof(FancyCharacter_OnSanityUpdate) == 0x000004, "Wrong size on FancyCharacter_OnSanityUpdate");
static_assert(offsetof(FancyCharacter_OnSanityUpdate, Sanity) == 0x000000, "Member 'FancyCharacter_OnSanityUpdate::Sanity' has a wrong offset!");

// Function Backrooms.FancyCharacter.SetCanCollide
// 0x0001 (0x0001 - 0x0000)
struct FancyCharacter_SetCanCollide final
{
public:
	bool                                          ShouldCollide;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyCharacter_SetCanCollide) == 0x000001, "Wrong alignment on FancyCharacter_SetCanCollide");
static_assert(sizeof(FancyCharacter_SetCanCollide) == 0x000001, "Wrong size on FancyCharacter_SetCanCollide");
static_assert(offsetof(FancyCharacter_SetCanCollide, ShouldCollide) == 0x000000, "Member 'FancyCharacter_SetCanCollide::ShouldCollide' has a wrong offset!");

// Function Backrooms.FancyCharacter.SetIsOverlapOnly
// 0x0001 (0x0001 - 0x0000)
struct FancyCharacter_SetIsOverlapOnly final
{
public:
	bool                                          ShouldOverlapOnly;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyCharacter_SetIsOverlapOnly) == 0x000001, "Wrong alignment on FancyCharacter_SetIsOverlapOnly");
static_assert(sizeof(FancyCharacter_SetIsOverlapOnly) == 0x000001, "Wrong size on FancyCharacter_SetIsOverlapOnly");
static_assert(offsetof(FancyCharacter_SetIsOverlapOnly, ShouldOverlapOnly) == 0x000000, "Member 'FancyCharacter_SetIsOverlapOnly::ShouldOverlapOnly' has a wrong offset!");

// Function Backrooms.FancyCharacter.ToggleBlur
// 0x0001 (0x0001 - 0x0000)
struct FancyCharacter_ToggleBlur final
{
public:
	bool                                          ShouldBlur;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyCharacter_ToggleBlur) == 0x000001, "Wrong alignment on FancyCharacter_ToggleBlur");
static_assert(sizeof(FancyCharacter_ToggleBlur) == 0x000001, "Wrong size on FancyCharacter_ToggleBlur");
static_assert(offsetof(FancyCharacter_ToggleBlur, ShouldBlur) == 0x000000, "Member 'FancyCharacter_ToggleBlur::ShouldBlur' has a wrong offset!");

// Function Backrooms.FancyCharacter.TogglePlayerLegs
// 0x0001 (0x0001 - 0x0000)
struct FancyCharacter_TogglePlayerLegs final
{
public:
	bool                                          IsHidden;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyCharacter_TogglePlayerLegs) == 0x000001, "Wrong alignment on FancyCharacter_TogglePlayerLegs");
static_assert(sizeof(FancyCharacter_TogglePlayerLegs) == 0x000001, "Wrong size on FancyCharacter_TogglePlayerLegs");
static_assert(offsetof(FancyCharacter_TogglePlayerLegs, IsHidden) == 0x000000, "Member 'FancyCharacter_TogglePlayerLegs::IsHidden' has a wrong offset!");

// Function Backrooms.FancyCharacter.TogglePlayerVisibility
// 0x0001 (0x0001 - 0x0000)
struct FancyCharacter_TogglePlayerVisibility final
{
public:
	bool                                          IsHidden;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyCharacter_TogglePlayerVisibility) == 0x000001, "Wrong alignment on FancyCharacter_TogglePlayerVisibility");
static_assert(sizeof(FancyCharacter_TogglePlayerVisibility) == 0x000001, "Wrong size on FancyCharacter_TogglePlayerVisibility");
static_assert(offsetof(FancyCharacter_TogglePlayerVisibility, IsHidden) == 0x000000, "Member 'FancyCharacter_TogglePlayerVisibility::IsHidden' has a wrong offset!");

// Function Backrooms.FancyGameInstance.CompleteMission
// 0x0068 (0x0068 - 0x0000)
struct FancyGameInstance_CompleteMission final
{
public:
	float                                         TimeCompleted;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMissionStructure                      ReturnValue;                                       // 0x0008(0x0060)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyGameInstance_CompleteMission) == 0x000008, "Wrong alignment on FancyGameInstance_CompleteMission");
static_assert(sizeof(FancyGameInstance_CompleteMission) == 0x000068, "Wrong size on FancyGameInstance_CompleteMission");
static_assert(offsetof(FancyGameInstance_CompleteMission, TimeCompleted) == 0x000000, "Member 'FancyGameInstance_CompleteMission::TimeCompleted' has a wrong offset!");
static_assert(offsetof(FancyGameInstance_CompleteMission, ReturnValue) == 0x000008, "Member 'FancyGameInstance_CompleteMission::ReturnValue' has a wrong offset!");

// Function Backrooms.FancyGameInstance.CreateMission
// 0x0028 (0x0028 - 0x0000)
struct FancyGameInstance_CreateMission final
{
public:
	class FString                                 TargetEscapeLevel;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelBaseXP;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelTimeLimit;                                    // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MissionStructRowName;                              // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyGameInstance_CreateMission) == 0x000008, "Wrong alignment on FancyGameInstance_CreateMission");
static_assert(sizeof(FancyGameInstance_CreateMission) == 0x000028, "Wrong size on FancyGameInstance_CreateMission");
static_assert(offsetof(FancyGameInstance_CreateMission, TargetEscapeLevel) == 0x000000, "Member 'FancyGameInstance_CreateMission::TargetEscapeLevel' has a wrong offset!");
static_assert(offsetof(FancyGameInstance_CreateMission, LevelBaseXP) == 0x000010, "Member 'FancyGameInstance_CreateMission::LevelBaseXP' has a wrong offset!");
static_assert(offsetof(FancyGameInstance_CreateMission, LevelTimeLimit) == 0x000014, "Member 'FancyGameInstance_CreateMission::LevelTimeLimit' has a wrong offset!");
static_assert(offsetof(FancyGameInstance_CreateMission, MissionStructRowName) == 0x000018, "Member 'FancyGameInstance_CreateMission::MissionStructRowName' has a wrong offset!");

// Function Backrooms.FancyGameInstance.GetCurrentGameLanguage
// 0x0010 (0x0010 - 0x0000)
struct FancyGameInstance_GetCurrentGameLanguage final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyGameInstance_GetCurrentGameLanguage) == 0x000008, "Wrong alignment on FancyGameInstance_GetCurrentGameLanguage");
static_assert(sizeof(FancyGameInstance_GetCurrentGameLanguage) == 0x000010, "Wrong size on FancyGameInstance_GetCurrentGameLanguage");
static_assert(offsetof(FancyGameInstance_GetCurrentGameLanguage, ReturnValue) == 0x000000, "Member 'FancyGameInstance_GetCurrentGameLanguage::ReturnValue' has a wrong offset!");

// Function Backrooms.FancyGameInstance.InitializeCPPElements
// 0x0001 (0x0001 - 0x0000)
struct FancyGameInstance_InitializeCPPElements final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyGameInstance_InitializeCPPElements) == 0x000001, "Wrong alignment on FancyGameInstance_InitializeCPPElements");
static_assert(sizeof(FancyGameInstance_InitializeCPPElements) == 0x000001, "Wrong size on FancyGameInstance_InitializeCPPElements");
static_assert(offsetof(FancyGameInstance_InitializeCPPElements, ReturnValue) == 0x000000, "Member 'FancyGameInstance_InitializeCPPElements::ReturnValue' has a wrong offset!");

// Function Backrooms.FancyGameInstance.OnSteamOverlayIsActive
// 0x0001 (0x0001 - 0x0000)
struct FancyGameInstance_OnSteamOverlayIsActive final
{
public:
	bool                                          IsOverlayActive;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyGameInstance_OnSteamOverlayIsActive) == 0x000001, "Wrong alignment on FancyGameInstance_OnSteamOverlayIsActive");
static_assert(sizeof(FancyGameInstance_OnSteamOverlayIsActive) == 0x000001, "Wrong size on FancyGameInstance_OnSteamOverlayIsActive");
static_assert(offsetof(FancyGameInstance_OnSteamOverlayIsActive, IsOverlayActive) == 0x000000, "Member 'FancyGameInstance_OnSteamOverlayIsActive::IsOverlayActive' has a wrong offset!");

// Function Backrooms.GripMotionControllerComponent.BP_IsLocallyControlled
// 0x0001 (0x0001 - 0x0000)
struct GripMotionControllerComponent_BP_IsLocallyControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GripMotionControllerComponent_BP_IsLocallyControlled) == 0x000001, "Wrong alignment on GripMotionControllerComponent_BP_IsLocallyControlled");
static_assert(sizeof(GripMotionControllerComponent_BP_IsLocallyControlled) == 0x000001, "Wrong size on GripMotionControllerComponent_BP_IsLocallyControlled");
static_assert(offsetof(GripMotionControllerComponent_BP_IsLocallyControlled, ReturnValue) == 0x000000, "Member 'GripMotionControllerComponent_BP_IsLocallyControlled::ReturnValue' has a wrong offset!");

// Function Backrooms.GripMotionControllerComponent.GetPhysicsVelocity
// 0x0018 (0x0018 - 0x0000)
struct GripMotionControllerComponent_GetPhysicsVelocity final
{
public:
	struct FVector                                AngularVelocity;                                   // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinearVelocity;                                    // 0x000C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GripMotionControllerComponent_GetPhysicsVelocity) == 0x000004, "Wrong alignment on GripMotionControllerComponent_GetPhysicsVelocity");
static_assert(sizeof(GripMotionControllerComponent_GetPhysicsVelocity) == 0x000018, "Wrong size on GripMotionControllerComponent_GetPhysicsVelocity");
static_assert(offsetof(GripMotionControllerComponent_GetPhysicsVelocity, AngularVelocity) == 0x000000, "Member 'GripMotionControllerComponent_GetPhysicsVelocity::AngularVelocity' has a wrong offset!");
static_assert(offsetof(GripMotionControllerComponent_GetPhysicsVelocity, LinearVelocity) == 0x00000C, "Member 'GripMotionControllerComponent_GetPhysicsVelocity::LinearVelocity' has a wrong offset!");

// Function Backrooms.GripMotionControllerComponent.Server_SendControllerTransform
// 0x0030 (0x0030 - 0x0000)
struct GripMotionControllerComponent_Server_SendControllerTransform final
{
public:
	struct FTransform                             NewTransform;                                      // 0x0000(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GripMotionControllerComponent_Server_SendControllerTransform) == 0x000010, "Wrong alignment on GripMotionControllerComponent_Server_SendControllerTransform");
static_assert(sizeof(GripMotionControllerComponent_Server_SendControllerTransform) == 0x000030, "Wrong size on GripMotionControllerComponent_Server_SendControllerTransform");
static_assert(offsetof(GripMotionControllerComponent_Server_SendControllerTransform, NewTransform) == 0x000000, "Member 'GripMotionControllerComponent_Server_SendControllerTransform::NewTransform' has a wrong offset!");

// Function Backrooms.FancyMovementComponent.SetSprinting
// 0x0001 (0x0001 - 0x0000)
struct FancyMovementComponent_SetSprinting final
{
public:
	bool                                          Sprint;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FancyMovementComponent_SetSprinting) == 0x000001, "Wrong alignment on FancyMovementComponent_SetSprinting");
static_assert(sizeof(FancyMovementComponent_SetSprinting) == 0x000001, "Wrong size on FancyMovementComponent_SetSprinting");
static_assert(offsetof(FancyMovementComponent_SetSprinting, Sprint) == 0x000000, "Member 'FancyMovementComponent_SetSprinting::Sprint' has a wrong offset!");

// Function Backrooms.FancyPlayerController.GetObjectScreenRadius
// 0x0010 (0x0010 - 0x0000)
struct FancyPlayerController_GetObjectScreenRadius final
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FancyPlayerController_GetObjectScreenRadius) == 0x000008, "Wrong alignment on FancyPlayerController_GetObjectScreenRadius");
static_assert(sizeof(FancyPlayerController_GetObjectScreenRadius) == 0x000010, "Wrong size on FancyPlayerController_GetObjectScreenRadius");
static_assert(offsetof(FancyPlayerController_GetObjectScreenRadius, MeshComponent) == 0x000000, "Member 'FancyPlayerController_GetObjectScreenRadius::MeshComponent' has a wrong offset!");
static_assert(offsetof(FancyPlayerController_GetObjectScreenRadius, ReturnValue) == 0x000008, "Member 'FancyPlayerController_GetObjectScreenRadius::ReturnValue' has a wrong offset!");

// Function Backrooms.InspectableActor.GetMesh
// 0x0008 (0x0008 - 0x0000)
struct InspectableActor_GetMesh final
{
public:
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InspectableActor_GetMesh) == 0x000008, "Wrong alignment on InspectableActor_GetMesh");
static_assert(sizeof(InspectableActor_GetMesh) == 0x000008, "Wrong size on InspectableActor_GetMesh");
static_assert(offsetof(InspectableActor_GetMesh, ReturnValue) == 0x000000, "Member 'InspectableActor_GetMesh::ReturnValue' has a wrong offset!");

// Function Backrooms.InspectableActor.SetCameraLocation
// 0x0008 (0x0008 - 0x0000)
struct InspectableActor_SetCameraLocation final
{
public:
	class UCameraComponent*                       CameraComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InspectableActor_SetCameraLocation) == 0x000008, "Wrong alignment on InspectableActor_SetCameraLocation");
static_assert(sizeof(InspectableActor_SetCameraLocation) == 0x000008, "Wrong size on InspectableActor_SetCameraLocation");
static_assert(offsetof(InspectableActor_SetCameraLocation, CameraComponent) == 0x000000, "Member 'InspectableActor_SetCameraLocation::CameraComponent' has a wrong offset!");

// Function Backrooms.InspectableActor.SetPlayerRef
// 0x0008 (0x0008 - 0x0000)
struct InspectableActor_SetPlayerRef final
{
public:
	class ACharacter*                             Ref;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InspectableActor_SetPlayerRef) == 0x000008, "Wrong alignment on InspectableActor_SetPlayerRef");
static_assert(sizeof(InspectableActor_SetPlayerRef) == 0x000008, "Wrong size on InspectableActor_SetPlayerRef");
static_assert(offsetof(InspectableActor_SetPlayerRef, Ref) == 0x000000, "Member 'InspectableActor_SetPlayerRef::Ref' has a wrong offset!");

// Function Backrooms.InteractableComponent.OnUsedServer
// 0x0008 (0x0008 - 0x0000)
struct InteractableComponent_OnUsedServer final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableComponent_OnUsedServer) == 0x000008, "Wrong alignment on InteractableComponent_OnUsedServer");
static_assert(sizeof(InteractableComponent_OnUsedServer) == 0x000008, "Wrong size on InteractableComponent_OnUsedServer");
static_assert(offsetof(InteractableComponent_OnUsedServer, Character) == 0x000000, "Member 'InteractableComponent_OnUsedServer::Character' has a wrong offset!");

// Function Backrooms.InteractableInterface.OnActorUsed
// 0x0008 (0x0008 - 0x0000)
struct InteractableInterface_OnActorUsed final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableInterface_OnActorUsed) == 0x000008, "Wrong alignment on InteractableInterface_OnActorUsed");
static_assert(sizeof(InteractableInterface_OnActorUsed) == 0x000008, "Wrong size on InteractableInterface_OnActorUsed");
static_assert(offsetof(InteractableInterface_OnActorUsed, Character) == 0x000000, "Member 'InteractableInterface_OnActorUsed::Character' has a wrong offset!");

// Function Backrooms.InventoryComponent.AddToInventory
// 0x0010 (0x0010 - 0x0000)
struct InventoryComponent_AddToInventory final
{
public:
	class UInventoryItem*                         Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryComponent_AddToInventory) == 0x000008, "Wrong alignment on InventoryComponent_AddToInventory");
static_assert(sizeof(InventoryComponent_AddToInventory) == 0x000010, "Wrong size on InventoryComponent_AddToInventory");
static_assert(offsetof(InventoryComponent_AddToInventory, Item) == 0x000000, "Member 'InventoryComponent_AddToInventory::Item' has a wrong offset!");
static_assert(offsetof(InventoryComponent_AddToInventory, ReturnValue) == 0x000008, "Member 'InventoryComponent_AddToInventory::ReturnValue' has a wrong offset!");

// Function Backrooms.InventoryComponent.DropItem
// 0x0001 (0x0001 - 0x0000)
struct InventoryComponent_DropItem final
{
public:
	uint8                                         Slot;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_DropItem) == 0x000001, "Wrong alignment on InventoryComponent_DropItem");
static_assert(sizeof(InventoryComponent_DropItem) == 0x000001, "Wrong size on InventoryComponent_DropItem");
static_assert(offsetof(InventoryComponent_DropItem, Slot) == 0x000000, "Member 'InventoryComponent_DropItem::Slot' has a wrong offset!");

// Function Backrooms.InventoryComponent.GetItemAtSlot
// 0x0010 (0x0010 - 0x0000)
struct InventoryComponent_GetItemAtSlot final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryItem*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetItemAtSlot) == 0x000008, "Wrong alignment on InventoryComponent_GetItemAtSlot");
static_assert(sizeof(InventoryComponent_GetItemAtSlot) == 0x000010, "Wrong size on InventoryComponent_GetItemAtSlot");
static_assert(offsetof(InventoryComponent_GetItemAtSlot, SlotIndex) == 0x000000, "Member 'InventoryComponent_GetItemAtSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(InventoryComponent_GetItemAtSlot, ReturnValue) == 0x000008, "Member 'InventoryComponent_GetItemAtSlot::ReturnValue' has a wrong offset!");

// Function Backrooms.InventoryComponent.IsSlotEmpty
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_IsSlotEmpty final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryComponent_IsSlotEmpty) == 0x000004, "Wrong alignment on InventoryComponent_IsSlotEmpty");
static_assert(sizeof(InventoryComponent_IsSlotEmpty) == 0x000008, "Wrong size on InventoryComponent_IsSlotEmpty");
static_assert(offsetof(InventoryComponent_IsSlotEmpty, SlotIndex) == 0x000000, "Member 'InventoryComponent_IsSlotEmpty::SlotIndex' has a wrong offset!");
static_assert(offsetof(InventoryComponent_IsSlotEmpty, ReturnValue) == 0x000004, "Member 'InventoryComponent_IsSlotEmpty::ReturnValue' has a wrong offset!");

// Function Backrooms.InventoryComponent.RemoveFromInventory
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_RemoveFromInventory final
{
public:
	class UInventoryItem*                         Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_RemoveFromInventory) == 0x000008, "Wrong alignment on InventoryComponent_RemoveFromInventory");
static_assert(sizeof(InventoryComponent_RemoveFromInventory) == 0x000008, "Wrong size on InventoryComponent_RemoveFromInventory");
static_assert(offsetof(InventoryComponent_RemoveFromInventory, Item) == 0x000000, "Member 'InventoryComponent_RemoveFromInventory::Item' has a wrong offset!");

// Function Backrooms.InventoryComponent.SwapInventoryItems
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_SwapInventoryItems final
{
public:
	int32                                         FirstIdx;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondIdx;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_SwapInventoryItems) == 0x000004, "Wrong alignment on InventoryComponent_SwapInventoryItems");
static_assert(sizeof(InventoryComponent_SwapInventoryItems) == 0x000008, "Wrong size on InventoryComponent_SwapInventoryItems");
static_assert(offsetof(InventoryComponent_SwapInventoryItems, FirstIdx) == 0x000000, "Member 'InventoryComponent_SwapInventoryItems::FirstIdx' has a wrong offset!");
static_assert(offsetof(InventoryComponent_SwapInventoryItems, SecondIdx) == 0x000004, "Member 'InventoryComponent_SwapInventoryItems::SecondIdx' has a wrong offset!");

// Function Backrooms.LIDARBlueprintFunctionLibrary.CreateLiDarDot
// 0x0020 (0x0020 - 0x0000)
struct LIDARBlueprintFunctionLibrary_CreateLiDarDot final
{
public:
	class UObject*                                Caller;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLIDARDotStruct                        ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LIDARBlueprintFunctionLibrary_CreateLiDarDot) == 0x000008, "Wrong alignment on LIDARBlueprintFunctionLibrary_CreateLiDarDot");
static_assert(sizeof(LIDARBlueprintFunctionLibrary_CreateLiDarDot) == 0x000020, "Wrong size on LIDARBlueprintFunctionLibrary_CreateLiDarDot");
static_assert(offsetof(LIDARBlueprintFunctionLibrary_CreateLiDarDot, Caller) == 0x000000, "Member 'LIDARBlueprintFunctionLibrary_CreateLiDarDot::Caller' has a wrong offset!");
static_assert(offsetof(LIDARBlueprintFunctionLibrary_CreateLiDarDot, RenderTarget) == 0x000008, "Member 'LIDARBlueprintFunctionLibrary_CreateLiDarDot::RenderTarget' has a wrong offset!");
static_assert(offsetof(LIDARBlueprintFunctionLibrary_CreateLiDarDot, ReturnValue) == 0x000010, "Member 'LIDARBlueprintFunctionLibrary_CreateLiDarDot::ReturnValue' has a wrong offset!");

// Function Backrooms.LIDARBlueprintFunctionLibrary.FindCollisionUVSkeletalMesh
// 0x0094 (0x0094 - 0x0000)
struct LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector2D                              UV;                                                // 0x0088(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh) == 0x000004, "Wrong alignment on LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh");
static_assert(sizeof(LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh) == 0x000094, "Wrong size on LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh");
static_assert(offsetof(LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh, Hit) == 0x000000, "Member 'LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh::Hit' has a wrong offset!");
static_assert(offsetof(LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh, UV) == 0x000088, "Member 'LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh::UV' has a wrong offset!");
static_assert(offsetof(LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh, ReturnValue) == 0x000090, "Member 'LIDARBlueprintFunctionLibrary_FindCollisionUVSkeletalMesh::ReturnValue' has a wrong offset!");

// Function Backrooms.LIDARComponent.ScannerTrace
// 0x0090 (0x0090 - 0x0000)
struct LIDARComponent_ScannerTrace final
{
public:
	class UStaticMeshComponent*                   Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             ReturnValue;                                       // 0x0008(0x0088)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LIDARComponent_ScannerTrace) == 0x000008, "Wrong alignment on LIDARComponent_ScannerTrace");
static_assert(sizeof(LIDARComponent_ScannerTrace) == 0x000090, "Wrong size on LIDARComponent_ScannerTrace");
static_assert(offsetof(LIDARComponent_ScannerTrace, Mesh) == 0x000000, "Member 'LIDARComponent_ScannerTrace::Mesh' has a wrong offset!");
static_assert(offsetof(LIDARComponent_ScannerTrace, ReturnValue) == 0x000008, "Member 'LIDARComponent_ScannerTrace::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorCharacterMovement.DecreaseSpeedMultiplier
// 0x0004 (0x0004 - 0x0000)
struct MapEditorCharacterMovement_DecreaseSpeedMultiplier final
{
public:
	float                                         DecreaseAmount;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorCharacterMovement_DecreaseSpeedMultiplier) == 0x000004, "Wrong alignment on MapEditorCharacterMovement_DecreaseSpeedMultiplier");
static_assert(sizeof(MapEditorCharacterMovement_DecreaseSpeedMultiplier) == 0x000004, "Wrong size on MapEditorCharacterMovement_DecreaseSpeedMultiplier");
static_assert(offsetof(MapEditorCharacterMovement_DecreaseSpeedMultiplier, DecreaseAmount) == 0x000000, "Member 'MapEditorCharacterMovement_DecreaseSpeedMultiplier::DecreaseAmount' has a wrong offset!");

// Function Backrooms.MapEditorCharacterMovement.EnterMovementMode
// 0x0001 (0x0001 - 0x0000)
struct MapEditorCharacterMovement_EnterMovementMode final
{
public:
	bool                                          Enter;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorCharacterMovement_EnterMovementMode) == 0x000001, "Wrong alignment on MapEditorCharacterMovement_EnterMovementMode");
static_assert(sizeof(MapEditorCharacterMovement_EnterMovementMode) == 0x000001, "Wrong size on MapEditorCharacterMovement_EnterMovementMode");
static_assert(offsetof(MapEditorCharacterMovement_EnterMovementMode, Enter) == 0x000000, "Member 'MapEditorCharacterMovement_EnterMovementMode::Enter' has a wrong offset!");

// Function Backrooms.MapEditorCharacterMovement.IncreaseSpeedMultiplier
// 0x0004 (0x0004 - 0x0000)
struct MapEditorCharacterMovement_IncreaseSpeedMultiplier final
{
public:
	float                                         IncreaseAmount;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorCharacterMovement_IncreaseSpeedMultiplier) == 0x000004, "Wrong alignment on MapEditorCharacterMovement_IncreaseSpeedMultiplier");
static_assert(sizeof(MapEditorCharacterMovement_IncreaseSpeedMultiplier) == 0x000004, "Wrong size on MapEditorCharacterMovement_IncreaseSpeedMultiplier");
static_assert(offsetof(MapEditorCharacterMovement_IncreaseSpeedMultiplier, IncreaseAmount) == 0x000000, "Member 'MapEditorCharacterMovement_IncreaseSpeedMultiplier::IncreaseAmount' has a wrong offset!");

// Function Backrooms.MapEditorCharacterMovement.LookUp
// 0x0004 (0x0004 - 0x0000)
struct MapEditorCharacterMovement_LookUp final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorCharacterMovement_LookUp) == 0x000004, "Wrong alignment on MapEditorCharacterMovement_LookUp");
static_assert(sizeof(MapEditorCharacterMovement_LookUp) == 0x000004, "Wrong size on MapEditorCharacterMovement_LookUp");
static_assert(offsetof(MapEditorCharacterMovement_LookUp, Value) == 0x000000, "Member 'MapEditorCharacterMovement_LookUp::Value' has a wrong offset!");

// Function Backrooms.MapEditorCharacterMovement.MoveForward
// 0x0004 (0x0004 - 0x0000)
struct MapEditorCharacterMovement_MoveForward final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorCharacterMovement_MoveForward) == 0x000004, "Wrong alignment on MapEditorCharacterMovement_MoveForward");
static_assert(sizeof(MapEditorCharacterMovement_MoveForward) == 0x000004, "Wrong size on MapEditorCharacterMovement_MoveForward");
static_assert(offsetof(MapEditorCharacterMovement_MoveForward, Value) == 0x000000, "Member 'MapEditorCharacterMovement_MoveForward::Value' has a wrong offset!");

// Function Backrooms.MapEditorCharacterMovement.MoveRight
// 0x0004 (0x0004 - 0x0000)
struct MapEditorCharacterMovement_MoveRight final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorCharacterMovement_MoveRight) == 0x000004, "Wrong alignment on MapEditorCharacterMovement_MoveRight");
static_assert(sizeof(MapEditorCharacterMovement_MoveRight) == 0x000004, "Wrong size on MapEditorCharacterMovement_MoveRight");
static_assert(offsetof(MapEditorCharacterMovement_MoveRight, Value) == 0x000000, "Member 'MapEditorCharacterMovement_MoveRight::Value' has a wrong offset!");

// Function Backrooms.MapEditorCharacterMovement.MoveUp
// 0x0004 (0x0004 - 0x0000)
struct MapEditorCharacterMovement_MoveUp final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorCharacterMovement_MoveUp) == 0x000004, "Wrong alignment on MapEditorCharacterMovement_MoveUp");
static_assert(sizeof(MapEditorCharacterMovement_MoveUp) == 0x000004, "Wrong size on MapEditorCharacterMovement_MoveUp");
static_assert(offsetof(MapEditorCharacterMovement_MoveUp, Value) == 0x000000, "Member 'MapEditorCharacterMovement_MoveUp::Value' has a wrong offset!");

// Function Backrooms.MapEditorCharacterMovement.Server_SetSpeedMultiplier
// 0x0004 (0x0004 - 0x0000)
struct MapEditorCharacterMovement_Server_SetSpeedMultiplier final
{
public:
	float                                         SpeedMultiplier;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorCharacterMovement_Server_SetSpeedMultiplier) == 0x000004, "Wrong alignment on MapEditorCharacterMovement_Server_SetSpeedMultiplier");
static_assert(sizeof(MapEditorCharacterMovement_Server_SetSpeedMultiplier) == 0x000004, "Wrong size on MapEditorCharacterMovement_Server_SetSpeedMultiplier");
static_assert(offsetof(MapEditorCharacterMovement_Server_SetSpeedMultiplier, SpeedMultiplier) == 0x000000, "Member 'MapEditorCharacterMovement_Server_SetSpeedMultiplier::SpeedMultiplier' has a wrong offset!");

// Function Backrooms.MapEditorCharacterMovement.Turn
// 0x0004 (0x0004 - 0x0000)
struct MapEditorCharacterMovement_Turn final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorCharacterMovement_Turn) == 0x000004, "Wrong alignment on MapEditorCharacterMovement_Turn");
static_assert(sizeof(MapEditorCharacterMovement_Turn) == 0x000004, "Wrong size on MapEditorCharacterMovement_Turn");
static_assert(offsetof(MapEditorCharacterMovement_Turn, Value) == 0x000000, "Member 'MapEditorCharacterMovement_Turn::Value' has a wrong offset!");

// Function Backrooms.MapEditorCharacterMovement.InMovementMode
// 0x0001 (0x0001 - 0x0000)
struct MapEditorCharacterMovement_InMovementMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorCharacterMovement_InMovementMode) == 0x000001, "Wrong alignment on MapEditorCharacterMovement_InMovementMode");
static_assert(sizeof(MapEditorCharacterMovement_InMovementMode) == 0x000001, "Wrong size on MapEditorCharacterMovement_InMovementMode");
static_assert(offsetof(MapEditorCharacterMovement_InMovementMode, ReturnValue) == 0x000000, "Member 'MapEditorCharacterMovement_InMovementMode::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.MouseTrace
// 0x0090 (0x0090 - 0x0000)
struct MapEditorHandlerComponent_MouseTrace final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitGizmo;                                         // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugLine;                                    // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ReturnValue;                                       // 0x0008(0x0088)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_MouseTrace) == 0x000004, "Wrong alignment on MapEditorHandlerComponent_MouseTrace");
static_assert(sizeof(MapEditorHandlerComponent_MouseTrace) == 0x000090, "Wrong size on MapEditorHandlerComponent_MouseTrace");
static_assert(offsetof(MapEditorHandlerComponent_MouseTrace, Distance) == 0x000000, "Member 'MapEditorHandlerComponent_MouseTrace::Distance' has a wrong offset!");
static_assert(offsetof(MapEditorHandlerComponent_MouseTrace, bHitGizmo) == 0x000004, "Member 'MapEditorHandlerComponent_MouseTrace::bHitGizmo' has a wrong offset!");
static_assert(offsetof(MapEditorHandlerComponent_MouseTrace, bDrawDebugLine) == 0x000005, "Member 'MapEditorHandlerComponent_MouseTrace::bDrawDebugLine' has a wrong offset!");
static_assert(offsetof(MapEditorHandlerComponent_MouseTrace, ReturnValue) == 0x000008, "Member 'MapEditorHandlerComponent_MouseTrace::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.Server_DeleteActor
// 0x0008 (0x0008 - 0x0000)
struct MapEditorHandlerComponent_Server_DeleteActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_Server_DeleteActor) == 0x000008, "Wrong alignment on MapEditorHandlerComponent_Server_DeleteActor");
static_assert(sizeof(MapEditorHandlerComponent_Server_DeleteActor) == 0x000008, "Wrong size on MapEditorHandlerComponent_Server_DeleteActor");
static_assert(offsetof(MapEditorHandlerComponent_Server_DeleteActor, Actor) == 0x000000, "Member 'MapEditorHandlerComponent_Server_DeleteActor::Actor' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.Server_ReplicateTransform
// 0x0040 (0x0040 - 0x0000)
struct MapEditorHandlerComponent_Server_ReplicateTransform final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_Server_ReplicateTransform) == 0x000010, "Wrong alignment on MapEditorHandlerComponent_Server_ReplicateTransform");
static_assert(sizeof(MapEditorHandlerComponent_Server_ReplicateTransform) == 0x000040, "Wrong size on MapEditorHandlerComponent_Server_ReplicateTransform");
static_assert(offsetof(MapEditorHandlerComponent_Server_ReplicateTransform, Actor) == 0x000000, "Member 'MapEditorHandlerComponent_Server_ReplicateTransform::Actor' has a wrong offset!");
static_assert(offsetof(MapEditorHandlerComponent_Server_ReplicateTransform, Transform) == 0x000010, "Member 'MapEditorHandlerComponent_Server_ReplicateTransform::Transform' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.Server_SpawnActor
// 0x0008 (0x0008 - 0x0000)
struct MapEditorHandlerComponent_Server_SpawnActor final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_Server_SpawnActor) == 0x000008, "Wrong alignment on MapEditorHandlerComponent_Server_SpawnActor");
static_assert(sizeof(MapEditorHandlerComponent_Server_SpawnActor) == 0x000008, "Wrong size on MapEditorHandlerComponent_Server_SpawnActor");
static_assert(offsetof(MapEditorHandlerComponent_Server_SpawnActor, ActorClass) == 0x000000, "Member 'MapEditorHandlerComponent_Server_SpawnActor::ActorClass' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.SetActor
// 0x0008 (0x0008 - 0x0000)
struct MapEditorHandlerComponent_SetActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_SetActor) == 0x000008, "Wrong alignment on MapEditorHandlerComponent_SetActor");
static_assert(sizeof(MapEditorHandlerComponent_SetActor) == 0x000008, "Wrong size on MapEditorHandlerComponent_SetActor");
static_assert(offsetof(MapEditorHandlerComponent_SetActor, Actor) == 0x000000, "Member 'MapEditorHandlerComponent_SetActor::Actor' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.SetActorTransform
// 0x0030 (0x0030 - 0x0000)
struct MapEditorHandlerComponent_SetActorTransform final
{
public:
	struct FTransform                             NewTransform;                                      // 0x0000(0x0030)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_SetActorTransform) == 0x000010, "Wrong alignment on MapEditorHandlerComponent_SetActorTransform");
static_assert(sizeof(MapEditorHandlerComponent_SetActorTransform) == 0x000030, "Wrong size on MapEditorHandlerComponent_SetActorTransform");
static_assert(offsetof(MapEditorHandlerComponent_SetActorTransform, NewTransform) == 0x000000, "Member 'MapEditorHandlerComponent_SetActorTransform::NewTransform' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.SetReturnPawn
// 0x0008 (0x0008 - 0x0000)
struct MapEditorHandlerComponent_SetReturnPawn final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_SetReturnPawn) == 0x000008, "Wrong alignment on MapEditorHandlerComponent_SetReturnPawn");
static_assert(sizeof(MapEditorHandlerComponent_SetReturnPawn) == 0x000008, "Wrong size on MapEditorHandlerComponent_SetReturnPawn");
static_assert(offsetof(MapEditorHandlerComponent_SetReturnPawn, Pawn) == 0x000000, "Member 'MapEditorHandlerComponent_SetReturnPawn::Pawn' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.SetSnapAmount
// 0x000C (0x000C - 0x0000)
struct MapEditorHandlerComponent_SetSnapAmount final
{
public:
	struct FMapEditorSnapping                     SnappingAmounts;                                   // 0x0000(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_SetSnapAmount) == 0x000004, "Wrong alignment on MapEditorHandlerComponent_SetSnapAmount");
static_assert(sizeof(MapEditorHandlerComponent_SetSnapAmount) == 0x00000C, "Wrong size on MapEditorHandlerComponent_SetSnapAmount");
static_assert(offsetof(MapEditorHandlerComponent_SetSnapAmount, SnappingAmounts) == 0x000000, "Member 'MapEditorHandlerComponent_SetSnapAmount::SnappingAmounts' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.SpawnActor
// 0x0008 (0x0008 - 0x0000)
struct MapEditorHandlerComponent_SpawnActor final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_SpawnActor) == 0x000008, "Wrong alignment on MapEditorHandlerComponent_SpawnActor");
static_assert(sizeof(MapEditorHandlerComponent_SpawnActor) == 0x000008, "Wrong size on MapEditorHandlerComponent_SpawnActor");
static_assert(offsetof(MapEditorHandlerComponent_SpawnActor, ActorClass) == 0x000000, "Member 'MapEditorHandlerComponent_SpawnActor::ActorClass' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.GetActorName
// 0x0010 (0x0010 - 0x0000)
struct MapEditorHandlerComponent_GetActorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_GetActorName) == 0x000008, "Wrong alignment on MapEditorHandlerComponent_GetActorName");
static_assert(sizeof(MapEditorHandlerComponent_GetActorName) == 0x000010, "Wrong size on MapEditorHandlerComponent_GetActorName");
static_assert(offsetof(MapEditorHandlerComponent_GetActorName, ReturnValue) == 0x000000, "Member 'MapEditorHandlerComponent_GetActorName::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.GetActorTransform
// 0x0030 (0x0030 - 0x0000)
struct MapEditorHandlerComponent_GetActorTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_GetActorTransform) == 0x000010, "Wrong alignment on MapEditorHandlerComponent_GetActorTransform");
static_assert(sizeof(MapEditorHandlerComponent_GetActorTransform) == 0x000030, "Wrong size on MapEditorHandlerComponent_GetActorTransform");
static_assert(offsetof(MapEditorHandlerComponent_GetActorTransform, ReturnValue) == 0x000000, "Member 'MapEditorHandlerComponent_GetActorTransform::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.GetGizmoType
// 0x0001 (0x0001 - 0x0000)
struct MapEditorHandlerComponent_GetGizmoType final
{
public:
	EGizmoType                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_GetGizmoType) == 0x000001, "Wrong alignment on MapEditorHandlerComponent_GetGizmoType");
static_assert(sizeof(MapEditorHandlerComponent_GetGizmoType) == 0x000001, "Wrong size on MapEditorHandlerComponent_GetGizmoType");
static_assert(offsetof(MapEditorHandlerComponent_GetGizmoType, ReturnValue) == 0x000000, "Member 'MapEditorHandlerComponent_GetGizmoType::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.GetReplicationRate
// 0x0004 (0x0004 - 0x0000)
struct MapEditorHandlerComponent_GetReplicationRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_GetReplicationRate) == 0x000004, "Wrong alignment on MapEditorHandlerComponent_GetReplicationRate");
static_assert(sizeof(MapEditorHandlerComponent_GetReplicationRate) == 0x000004, "Wrong size on MapEditorHandlerComponent_GetReplicationRate");
static_assert(offsetof(MapEditorHandlerComponent_GetReplicationRate, ReturnValue) == 0x000000, "Member 'MapEditorHandlerComponent_GetReplicationRate::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.GetSnapAmount
// 0x000C (0x000C - 0x0000)
struct MapEditorHandlerComponent_GetSnapAmount final
{
public:
	struct FMapEditorSnapping                     ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_GetSnapAmount) == 0x000004, "Wrong alignment on MapEditorHandlerComponent_GetSnapAmount");
static_assert(sizeof(MapEditorHandlerComponent_GetSnapAmount) == 0x00000C, "Wrong size on MapEditorHandlerComponent_GetSnapAmount");
static_assert(offsetof(MapEditorHandlerComponent_GetSnapAmount, ReturnValue) == 0x000000, "Member 'MapEditorHandlerComponent_GetSnapAmount::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorHandlerComponent.HasValidReturnPawn
// 0x0001 (0x0001 - 0x0000)
struct MapEditorHandlerComponent_HasValidReturnPawn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorHandlerComponent_HasValidReturnPawn) == 0x000001, "Wrong alignment on MapEditorHandlerComponent_HasValidReturnPawn");
static_assert(sizeof(MapEditorHandlerComponent_HasValidReturnPawn) == 0x000001, "Wrong size on MapEditorHandlerComponent_HasValidReturnPawn");
static_assert(offsetof(MapEditorHandlerComponent_HasValidReturnPawn, ReturnValue) == 0x000000, "Member 'MapEditorHandlerComponent_HasValidReturnPawn::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorInterface.OnMaterialLoaded
// 0x0020 (0x0020 - 0x0000)
struct MapEditorInterface_OnMaterialLoaded final
{
public:
	struct FMapEditorItemMaterial                 MapEditorItemMaterial;                             // 0x0000(0x0020)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorInterface_OnMaterialLoaded) == 0x000008, "Wrong alignment on MapEditorInterface_OnMaterialLoaded");
static_assert(sizeof(MapEditorInterface_OnMaterialLoaded) == 0x000020, "Wrong size on MapEditorInterface_OnMaterialLoaded");
static_assert(offsetof(MapEditorInterface_OnMaterialLoaded, MapEditorItemMaterial) == 0x000000, "Member 'MapEditorInterface_OnMaterialLoaded::MapEditorItemMaterial' has a wrong offset!");

// Function Backrooms.MapEditorInterface.OnScaleChanged
// 0x000C (0x000C - 0x0000)
struct MapEditorInterface_OnScaleChanged final
{
public:
	struct FVector                                NewScale;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorInterface_OnScaleChanged) == 0x000004, "Wrong alignment on MapEditorInterface_OnScaleChanged");
static_assert(sizeof(MapEditorInterface_OnScaleChanged) == 0x00000C, "Wrong size on MapEditorInterface_OnScaleChanged");
static_assert(offsetof(MapEditorInterface_OnScaleChanged, NewScale) == 0x000000, "Member 'MapEditorInterface_OnScaleChanged::NewScale' has a wrong offset!");

// Function Backrooms.MapEditorStatics.ClearMap
// 0x0008 (0x0008 - 0x0000)
struct MapEditorStatics_ClearMap final
{
public:
	class AActor*                                 WorldActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorStatics_ClearMap) == 0x000008, "Wrong alignment on MapEditorStatics_ClearMap");
static_assert(sizeof(MapEditorStatics_ClearMap) == 0x000008, "Wrong size on MapEditorStatics_ClearMap");
static_assert(offsetof(MapEditorStatics_ClearMap, WorldActor) == 0x000000, "Member 'MapEditorStatics_ClearMap::WorldActor' has a wrong offset!");

// Function Backrooms.MapEditorStatics.DeSerializeLevel
// 0x0028 (0x0028 - 0x0000)
struct MapEditorStatics_DeSerializeLevel final
{
public:
	class FString                                 JsonString;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMapEditorItems                        ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorStatics_DeSerializeLevel) == 0x000008, "Wrong alignment on MapEditorStatics_DeSerializeLevel");
static_assert(sizeof(MapEditorStatics_DeSerializeLevel) == 0x000028, "Wrong size on MapEditorStatics_DeSerializeLevel");
static_assert(offsetof(MapEditorStatics_DeSerializeLevel, JsonString) == 0x000000, "Member 'MapEditorStatics_DeSerializeLevel::JsonString' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_DeSerializeLevel, Success) == 0x000010, "Member 'MapEditorStatics_DeSerializeLevel::Success' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_DeSerializeLevel, ReturnValue) == 0x000018, "Member 'MapEditorStatics_DeSerializeLevel::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorStatics.DoesMapExist
// 0x0030 (0x0030 - 0x0000)
struct MapEditorStatics_DoesMapExist final
{
public:
	class AActor*                                 WorldActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapDirectory;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MapEditorStatics_DoesMapExist) == 0x000008, "Wrong alignment on MapEditorStatics_DoesMapExist");
static_assert(sizeof(MapEditorStatics_DoesMapExist) == 0x000030, "Wrong size on MapEditorStatics_DoesMapExist");
static_assert(offsetof(MapEditorStatics_DoesMapExist, WorldActor) == 0x000000, "Member 'MapEditorStatics_DoesMapExist::WorldActor' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_DoesMapExist, MapDirectory) == 0x000008, "Member 'MapEditorStatics_DoesMapExist::MapDirectory' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_DoesMapExist, MapName) == 0x000018, "Member 'MapEditorStatics_DoesMapExist::MapName' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_DoesMapExist, ReturnValue) == 0x000028, "Member 'MapEditorStatics_DoesMapExist::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorStatics.GetMapList
// 0x0030 (0x0030 - 0x0000)
struct MapEditorStatics_GetMapList final
{
public:
	class AActor*                                 WorldActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Directory;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCutLevelname;                                     // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAllMaps;                                      // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorStatics_GetMapList) == 0x000008, "Wrong alignment on MapEditorStatics_GetMapList");
static_assert(sizeof(MapEditorStatics_GetMapList) == 0x000030, "Wrong size on MapEditorStatics_GetMapList");
static_assert(offsetof(MapEditorStatics_GetMapList, WorldActor) == 0x000000, "Member 'MapEditorStatics_GetMapList::WorldActor' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_GetMapList, Directory) == 0x000008, "Member 'MapEditorStatics_GetMapList::Directory' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_GetMapList, bCutLevelname) == 0x000018, "Member 'MapEditorStatics_GetMapList::bCutLevelname' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_GetMapList, bShowAllMaps) == 0x000019, "Member 'MapEditorStatics_GetMapList::bShowAllMaps' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_GetMapList, ReturnValue) == 0x000020, "Member 'MapEditorStatics_GetMapList::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorStatics.GetRealMapName
// 0x0020 (0x0020 - 0x0000)
struct MapEditorStatics_GetRealMapName final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorStatics_GetRealMapName) == 0x000008, "Wrong alignment on MapEditorStatics_GetRealMapName");
static_assert(sizeof(MapEditorStatics_GetRealMapName) == 0x000020, "Wrong size on MapEditorStatics_GetRealMapName");
static_assert(offsetof(MapEditorStatics_GetRealMapName, MapName) == 0x000000, "Member 'MapEditorStatics_GetRealMapName::MapName' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_GetRealMapName, ReturnValue) == 0x000010, "Member 'MapEditorStatics_GetRealMapName::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorStatics.LoadMapFromFile
// 0x0060 (0x0060 - 0x0000)
struct MapEditorStatics_LoadMapFromFile final
{
public:
	class AActor*                                 WorldActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapDirectory;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Extension;                                         // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutString;                                         // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FullMapName;                                       // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MapEditorStatics_LoadMapFromFile) == 0x000008, "Wrong alignment on MapEditorStatics_LoadMapFromFile");
static_assert(sizeof(MapEditorStatics_LoadMapFromFile) == 0x000060, "Wrong size on MapEditorStatics_LoadMapFromFile");
static_assert(offsetof(MapEditorStatics_LoadMapFromFile, WorldActor) == 0x000000, "Member 'MapEditorStatics_LoadMapFromFile::WorldActor' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_LoadMapFromFile, MapDirectory) == 0x000008, "Member 'MapEditorStatics_LoadMapFromFile::MapDirectory' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_LoadMapFromFile, MapName) == 0x000018, "Member 'MapEditorStatics_LoadMapFromFile::MapName' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_LoadMapFromFile, Extension) == 0x000028, "Member 'MapEditorStatics_LoadMapFromFile::Extension' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_LoadMapFromFile, OutString) == 0x000038, "Member 'MapEditorStatics_LoadMapFromFile::OutString' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_LoadMapFromFile, FullMapName) == 0x000048, "Member 'MapEditorStatics_LoadMapFromFile::FullMapName' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_LoadMapFromFile, ReturnValue) == 0x000058, "Member 'MapEditorStatics_LoadMapFromFile::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorStatics.RemoveExtension
// 0x0020 (0x0020 - 0x0000)
struct MapEditorStatics_RemoveExtension final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorStatics_RemoveExtension) == 0x000008, "Wrong alignment on MapEditorStatics_RemoveExtension");
static_assert(sizeof(MapEditorStatics_RemoveExtension) == 0x000020, "Wrong size on MapEditorStatics_RemoveExtension");
static_assert(offsetof(MapEditorStatics_RemoveExtension, String) == 0x000000, "Member 'MapEditorStatics_RemoveExtension::String' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_RemoveExtension, ReturnValue) == 0x000010, "Member 'MapEditorStatics_RemoveExtension::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorStatics.SaveMapToFile
// 0x0050 (0x0050 - 0x0000)
struct MapEditorStatics_SaveMapToFile final
{
public:
	class AActor*                                 WorldActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapDirectory;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringToSave;                                      // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FullMapName;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MapEditorStatics_SaveMapToFile) == 0x000008, "Wrong alignment on MapEditorStatics_SaveMapToFile");
static_assert(sizeof(MapEditorStatics_SaveMapToFile) == 0x000050, "Wrong size on MapEditorStatics_SaveMapToFile");
static_assert(offsetof(MapEditorStatics_SaveMapToFile, WorldActor) == 0x000000, "Member 'MapEditorStatics_SaveMapToFile::WorldActor' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_SaveMapToFile, MapDirectory) == 0x000008, "Member 'MapEditorStatics_SaveMapToFile::MapDirectory' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_SaveMapToFile, MapName) == 0x000018, "Member 'MapEditorStatics_SaveMapToFile::MapName' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_SaveMapToFile, StringToSave) == 0x000028, "Member 'MapEditorStatics_SaveMapToFile::StringToSave' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_SaveMapToFile, FullMapName) == 0x000038, "Member 'MapEditorStatics_SaveMapToFile::FullMapName' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_SaveMapToFile, ReturnValue) == 0x000048, "Member 'MapEditorStatics_SaveMapToFile::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorStatics.SerializeLevel
// 0x0020 (0x0020 - 0x0000)
struct MapEditorStatics_SerializeLevel final
{
public:
	class AActor*                                 WorldActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorStatics_SerializeLevel) == 0x000008, "Wrong alignment on MapEditorStatics_SerializeLevel");
static_assert(sizeof(MapEditorStatics_SerializeLevel) == 0x000020, "Wrong size on MapEditorStatics_SerializeLevel");
static_assert(offsetof(MapEditorStatics_SerializeLevel, WorldActor) == 0x000000, "Member 'MapEditorStatics_SerializeLevel::WorldActor' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_SerializeLevel, Success) == 0x000008, "Member 'MapEditorStatics_SerializeLevel::Success' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_SerializeLevel, ReturnValue) == 0x000010, "Member 'MapEditorStatics_SerializeLevel::ReturnValue' has a wrong offset!");

// Function Backrooms.MapEditorStatics.SetMaterials
// 0x0020 (0x0020 - 0x0000)
struct MapEditorStatics_SetMaterials final
{
public:
	struct FMapEditorItemMaterial                 MapEditorItemMaterial;                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorStatics_SetMaterials) == 0x000008, "Wrong alignment on MapEditorStatics_SetMaterials");
static_assert(sizeof(MapEditorStatics_SetMaterials) == 0x000020, "Wrong size on MapEditorStatics_SetMaterials");
static_assert(offsetof(MapEditorStatics_SetMaterials, MapEditorItemMaterial) == 0x000000, "Member 'MapEditorStatics_SetMaterials::MapEditorItemMaterial' has a wrong offset!");

// Function Backrooms.MapEditorStatics.SpawnMapItems
// 0x0018 (0x0018 - 0x0000)
struct MapEditorStatics_SpawnMapItems final
{
public:
	class AActor*                                 WorldActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapEditorItems                        MapItems;                                          // 0x0008(0x0010)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorStatics_SpawnMapItems) == 0x000008, "Wrong alignment on MapEditorStatics_SpawnMapItems");
static_assert(sizeof(MapEditorStatics_SpawnMapItems) == 0x000018, "Wrong size on MapEditorStatics_SpawnMapItems");
static_assert(offsetof(MapEditorStatics_SpawnMapItems, WorldActor) == 0x000000, "Member 'MapEditorStatics_SpawnMapItems::WorldActor' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_SpawnMapItems, MapItems) == 0x000008, "Member 'MapEditorStatics_SpawnMapItems::MapItems' has a wrong offset!");

// Function Backrooms.MapEditorStatics.SpawnMapItemsFromJson
// 0x0018 (0x0018 - 0x0000)
struct MapEditorStatics_SpawnMapItemsFromJson final
{
public:
	class AActor*                                 WorldActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JsonString;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapEditorStatics_SpawnMapItemsFromJson) == 0x000008, "Wrong alignment on MapEditorStatics_SpawnMapItemsFromJson");
static_assert(sizeof(MapEditorStatics_SpawnMapItemsFromJson) == 0x000018, "Wrong size on MapEditorStatics_SpawnMapItemsFromJson");
static_assert(offsetof(MapEditorStatics_SpawnMapItemsFromJson, WorldActor) == 0x000000, "Member 'MapEditorStatics_SpawnMapItemsFromJson::WorldActor' has a wrong offset!");
static_assert(offsetof(MapEditorStatics_SpawnMapItemsFromJson, JsonString) == 0x000008, "Member 'MapEditorStatics_SpawnMapItemsFromJson::JsonString' has a wrong offset!");

// Function Backrooms.MissionData.SetTimeCompleted
// 0x0004 (0x0004 - 0x0000)
struct MissionData_SetTimeCompleted final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MissionData_SetTimeCompleted) == 0x000004, "Wrong alignment on MissionData_SetTimeCompleted");
static_assert(sizeof(MissionData_SetTimeCompleted) == 0x000004, "Wrong size on MissionData_SetTimeCompleted");
static_assert(offsetof(MissionData_SetTimeCompleted, Time) == 0x000000, "Member 'MissionData_SetTimeCompleted::Time' has a wrong offset!");

// DelegateFunction Backrooms.MotionScannerComponent.ScannerWaveUpdateDelegate__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct MotionScannerComponent_ScannerWaveUpdateDelegate__DelegateSignature final
{
public:
	TArray<struct FTargetsStruct>                 OutTargets;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FTelemetryStruct                       OutTelemetry;                                      // 0x0010(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MotionScannerComponent_ScannerWaveUpdateDelegate__DelegateSignature) == 0x000008, "Wrong alignment on MotionScannerComponent_ScannerWaveUpdateDelegate__DelegateSignature");
static_assert(sizeof(MotionScannerComponent_ScannerWaveUpdateDelegate__DelegateSignature) == 0x000018, "Wrong size on MotionScannerComponent_ScannerWaveUpdateDelegate__DelegateSignature");
static_assert(offsetof(MotionScannerComponent_ScannerWaveUpdateDelegate__DelegateSignature, OutTargets) == 0x000000, "Member 'MotionScannerComponent_ScannerWaveUpdateDelegate__DelegateSignature::OutTargets' has a wrong offset!");
static_assert(offsetof(MotionScannerComponent_ScannerWaveUpdateDelegate__DelegateSignature, OutTelemetry) == 0x000010, "Member 'MotionScannerComponent_ScannerWaveUpdateDelegate__DelegateSignature::OutTelemetry' has a wrong offset!");

// Function Backrooms.MotionScannerComponent.SetNewScanDistance
// 0x0004 (0x0004 - 0x0000)
struct MotionScannerComponent_SetNewScanDistance final
{
public:
	float                                         SetDistance;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MotionScannerComponent_SetNewScanDistance) == 0x000004, "Wrong alignment on MotionScannerComponent_SetNewScanDistance");
static_assert(sizeof(MotionScannerComponent_SetNewScanDistance) == 0x000004, "Wrong size on MotionScannerComponent_SetNewScanDistance");
static_assert(offsetof(MotionScannerComponent_SetNewScanDistance, SetDistance) == 0x000000, "Member 'MotionScannerComponent_SetNewScanDistance::SetDistance' has a wrong offset!");

// Function Backrooms.PushableActor.GetClosesPoint
// 0x0018 (0x0018 - 0x0000)
struct PushableActor_GetClosesPoint final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PushableActor_GetClosesPoint) == 0x000008, "Wrong alignment on PushableActor_GetClosesPoint");
static_assert(sizeof(PushableActor_GetClosesPoint) == 0x000018, "Wrong size on PushableActor_GetClosesPoint");
static_assert(offsetof(PushableActor_GetClosesPoint, InActor) == 0x000000, "Member 'PushableActor_GetClosesPoint::InActor' has a wrong offset!");
static_assert(offsetof(PushableActor_GetClosesPoint, ReturnValue) == 0x000008, "Member 'PushableActor_GetClosesPoint::ReturnValue' has a wrong offset!");

// Function Backrooms.PushableActor.GetForwardBoundingPoints
// 0x0018 (0x0018 - 0x0000)
struct PushableActor_GetForwardBoundingPoints final
{
public:
	bool                                          InInvert;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PushableActor_GetForwardBoundingPoints) == 0x000008, "Wrong alignment on PushableActor_GetForwardBoundingPoints");
static_assert(sizeof(PushableActor_GetForwardBoundingPoints) == 0x000018, "Wrong size on PushableActor_GetForwardBoundingPoints");
static_assert(offsetof(PushableActor_GetForwardBoundingPoints, InInvert) == 0x000000, "Member 'PushableActor_GetForwardBoundingPoints::InInvert' has a wrong offset!");
static_assert(offsetof(PushableActor_GetForwardBoundingPoints, ReturnValue) == 0x000008, "Member 'PushableActor_GetForwardBoundingPoints::ReturnValue' has a wrong offset!");

// Function Backrooms.PushableActor.GetRightBoundingPoints
// 0x0018 (0x0018 - 0x0000)
struct PushableActor_GetRightBoundingPoints final
{
public:
	bool                                          InInvert;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PushableActor_GetRightBoundingPoints) == 0x000008, "Wrong alignment on PushableActor_GetRightBoundingPoints");
static_assert(sizeof(PushableActor_GetRightBoundingPoints) == 0x000018, "Wrong size on PushableActor_GetRightBoundingPoints");
static_assert(offsetof(PushableActor_GetRightBoundingPoints, InInvert) == 0x000000, "Member 'PushableActor_GetRightBoundingPoints::InInvert' has a wrong offset!");
static_assert(offsetof(PushableActor_GetRightBoundingPoints, ReturnValue) == 0x000008, "Member 'PushableActor_GetRightBoundingPoints::ReturnValue' has a wrong offset!");

// DelegateFunction Backrooms.RadarPlayerComponent.ScannerWaveUpdateDelegate__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct RadarPlayerComponent_ScannerWaveUpdateDelegate__DelegateSignature final
{
public:
	TArray<struct FRadarTargetStruct>             OutTargets;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FTelemetryStruct                       OutTelemetry;                                      // 0x0010(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(RadarPlayerComponent_ScannerWaveUpdateDelegate__DelegateSignature) == 0x000008, "Wrong alignment on RadarPlayerComponent_ScannerWaveUpdateDelegate__DelegateSignature");
static_assert(sizeof(RadarPlayerComponent_ScannerWaveUpdateDelegate__DelegateSignature) == 0x000018, "Wrong size on RadarPlayerComponent_ScannerWaveUpdateDelegate__DelegateSignature");
static_assert(offsetof(RadarPlayerComponent_ScannerWaveUpdateDelegate__DelegateSignature, OutTargets) == 0x000000, "Member 'RadarPlayerComponent_ScannerWaveUpdateDelegate__DelegateSignature::OutTargets' has a wrong offset!");
static_assert(offsetof(RadarPlayerComponent_ScannerWaveUpdateDelegate__DelegateSignature, OutTelemetry) == 0x000010, "Member 'RadarPlayerComponent_ScannerWaveUpdateDelegate__DelegateSignature::OutTelemetry' has a wrong offset!");

// Function Backrooms.RadarPlayerComponent.SetNewScanDistance
// 0x0004 (0x0004 - 0x0000)
struct RadarPlayerComponent_SetNewScanDistance final
{
public:
	float                                         SetDistance;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RadarPlayerComponent_SetNewScanDistance) == 0x000004, "Wrong alignment on RadarPlayerComponent_SetNewScanDistance");
static_assert(sizeof(RadarPlayerComponent_SetNewScanDistance) == 0x000004, "Wrong size on RadarPlayerComponent_SetNewScanDistance");
static_assert(offsetof(RadarPlayerComponent_SetNewScanDistance, SetDistance) == 0x000000, "Member 'RadarPlayerComponent_SetNewScanDistance::SetDistance' has a wrong offset!");

}

